<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>1. JS 的数据类型 | 首页</title>
    <meta name="generator" content="VuePress 1.9.7">
    <link rel="icon" href="/Front-end-go-on/logo.png">
    <meta name="description" content="前端记录">
    
    <link rel="preload" href="/Front-end-go-on/assets/css/0.styles.2a02a9f8.css" as="style"><link rel="preload" href="/Front-end-go-on/assets/js/app.516772f1.js" as="script"><link rel="preload" href="/Front-end-go-on/assets/js/2.0a3bc84c.js" as="script"><link rel="preload" href="/Front-end-go-on/assets/js/20.a1860b1a.js" as="script"><link rel="prefetch" href="/Front-end-go-on/assets/js/10.6642f1f6.js"><link rel="prefetch" href="/Front-end-go-on/assets/js/11.4e0ee6ed.js"><link rel="prefetch" href="/Front-end-go-on/assets/js/12.80211777.js"><link rel="prefetch" href="/Front-end-go-on/assets/js/13.44d00f81.js"><link rel="prefetch" href="/Front-end-go-on/assets/js/14.0e1b59bb.js"><link rel="prefetch" href="/Front-end-go-on/assets/js/15.83fd0913.js"><link rel="prefetch" href="/Front-end-go-on/assets/js/16.80eef748.js"><link rel="prefetch" href="/Front-end-go-on/assets/js/17.23b91de5.js"><link rel="prefetch" href="/Front-end-go-on/assets/js/18.5fce1c63.js"><link rel="prefetch" href="/Front-end-go-on/assets/js/19.41e4122c.js"><link rel="prefetch" href="/Front-end-go-on/assets/js/21.e9b12237.js"><link rel="prefetch" href="/Front-end-go-on/assets/js/22.8f045a38.js"><link rel="prefetch" href="/Front-end-go-on/assets/js/23.c703c450.js"><link rel="prefetch" href="/Front-end-go-on/assets/js/24.5e3ccb9d.js"><link rel="prefetch" href="/Front-end-go-on/assets/js/25.eb6bced0.js"><link rel="prefetch" href="/Front-end-go-on/assets/js/26.c348beb7.js"><link rel="prefetch" href="/Front-end-go-on/assets/js/27.f8f7adca.js"><link rel="prefetch" href="/Front-end-go-on/assets/js/28.9c430ba3.js"><link rel="prefetch" href="/Front-end-go-on/assets/js/29.edf8a7f2.js"><link rel="prefetch" href="/Front-end-go-on/assets/js/3.01d462e4.js"><link rel="prefetch" href="/Front-end-go-on/assets/js/30.882246fc.js"><link rel="prefetch" href="/Front-end-go-on/assets/js/31.b0703001.js"><link rel="prefetch" href="/Front-end-go-on/assets/js/32.0f2d5bf9.js"><link rel="prefetch" href="/Front-end-go-on/assets/js/33.a9a1564a.js"><link rel="prefetch" href="/Front-end-go-on/assets/js/34.af7cb127.js"><link rel="prefetch" href="/Front-end-go-on/assets/js/35.e15ef094.js"><link rel="prefetch" href="/Front-end-go-on/assets/js/36.7c07f481.js"><link rel="prefetch" href="/Front-end-go-on/assets/js/37.5b5326a4.js"><link rel="prefetch" href="/Front-end-go-on/assets/js/38.031f4f72.js"><link rel="prefetch" href="/Front-end-go-on/assets/js/39.a56ed823.js"><link rel="prefetch" href="/Front-end-go-on/assets/js/4.c7bba60a.js"><link rel="prefetch" href="/Front-end-go-on/assets/js/40.899c4c2c.js"><link rel="prefetch" href="/Front-end-go-on/assets/js/41.081d1af3.js"><link rel="prefetch" href="/Front-end-go-on/assets/js/42.1c4c1ed6.js"><link rel="prefetch" href="/Front-end-go-on/assets/js/43.cd76dd6e.js"><link rel="prefetch" href="/Front-end-go-on/assets/js/44.b4ee6e17.js"><link rel="prefetch" href="/Front-end-go-on/assets/js/45.680f9644.js"><link rel="prefetch" href="/Front-end-go-on/assets/js/46.37953d66.js"><link rel="prefetch" href="/Front-end-go-on/assets/js/47.3d75f4f3.js"><link rel="prefetch" href="/Front-end-go-on/assets/js/48.cb48db4c.js"><link rel="prefetch" href="/Front-end-go-on/assets/js/49.d93f4ef4.js"><link rel="prefetch" href="/Front-end-go-on/assets/js/5.608219c2.js"><link rel="prefetch" href="/Front-end-go-on/assets/js/50.89e5831d.js"><link rel="prefetch" href="/Front-end-go-on/assets/js/51.6c23431a.js"><link rel="prefetch" href="/Front-end-go-on/assets/js/52.ff0b1017.js"><link rel="prefetch" href="/Front-end-go-on/assets/js/53.74f7f782.js"><link rel="prefetch" href="/Front-end-go-on/assets/js/54.bf248b57.js"><link rel="prefetch" href="/Front-end-go-on/assets/js/55.71bcb67d.js"><link rel="prefetch" href="/Front-end-go-on/assets/js/56.28416af0.js"><link rel="prefetch" href="/Front-end-go-on/assets/js/57.f1484194.js"><link rel="prefetch" href="/Front-end-go-on/assets/js/58.33847e58.js"><link rel="prefetch" href="/Front-end-go-on/assets/js/59.213aa1d0.js"><link rel="prefetch" href="/Front-end-go-on/assets/js/6.853f7702.js"><link rel="prefetch" href="/Front-end-go-on/assets/js/60.00b7f372.js"><link rel="prefetch" href="/Front-end-go-on/assets/js/61.40005d3e.js"><link rel="prefetch" href="/Front-end-go-on/assets/js/7.3f4eaf4b.js"><link rel="prefetch" href="/Front-end-go-on/assets/js/8.d677b5a8.js"><link rel="prefetch" href="/Front-end-go-on/assets/js/9.ed7d2509.js">
    <link rel="stylesheet" href="/Front-end-go-on/assets/css/0.styles.2a02a9f8.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/Front-end-go-on/" class="home-link router-link-active"><img src="/Front-end-go-on/logo.png" alt="首页" class="logo"> <span class="site-name can-hide">首页</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/Front-end-go-on/pages/frontend/base/Html.html" class="nav-link">
  前端
</a></div><div class="nav-item"><a href="/Front-end-go-on/pages/otherLang/node/base.html" class="nav-link">
  非前端
</a></div><div class="nav-item"><a href="/Front-end-go-on/pages/assit/chrome/Extension.html" class="nav-link">
  辅助
</a></div><div class="nav-item"><a href="https://github.com/lll618xxx" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/Front-end-go-on/pages/frontend/base/Html.html" class="nav-link">
  前端
</a></div><div class="nav-item"><a href="/Front-end-go-on/pages/otherLang/node/base.html" class="nav-link">
  非前端
</a></div><div class="nav-item"><a href="/Front-end-go-on/pages/assit/chrome/Extension.html" class="nav-link">
  辅助
</a></div><div class="nav-item"><a href="https://github.com/lll618xxx" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>前端基础</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/Front-end-go-on/pages/frontend/base/Html.html" class="sidebar-link">HTML基础</a></li><li><a href="/Front-end-go-on/pages/frontend/base/Css.html" class="sidebar-link">CSS基础</a></li><li><a href="/Front-end-go-on/pages/frontend/base/Js.html" aria-current="page" class="active sidebar-link">JS基础</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/Front-end-go-on/pages/frontend/base/Js.html#_1-js-的数据类型" class="sidebar-link">1. JS 的数据类型</a></li><li class="sidebar-sub-header"><a href="/Front-end-go-on/pages/frontend/base/Js.html#_2-tpyeof-可以返回多少种值" class="sidebar-link">2. tpyeof 可以返回多少种值</a></li><li class="sidebar-sub-header"><a href="/Front-end-go-on/pages/frontend/base/Js.html#_3-js-中-new-一个对象会发生什么" class="sidebar-link">3. JS 中 new 一个对象会发生什么</a></li><li class="sidebar-sub-header"><a href="/Front-end-go-on/pages/frontend/base/Js.html#_4-预解析" class="sidebar-link">4. 预解析</a></li><li class="sidebar-sub-header"><a href="/Front-end-go-on/pages/frontend/base/Js.html#_5-call、apply-和-bind-的理解" class="sidebar-link">5. call、apply 和 bind 的理解</a></li><li class="sidebar-sub-header"><a href="/Front-end-go-on/pages/frontend/base/Js.html#_6-事件绑定-3-种方法" class="sidebar-link">6. 事件绑定 3 种方法</a></li><li class="sidebar-sub-header"><a href="/Front-end-go-on/pages/frontend/base/Js.html#_7-事件冒泡、捕获和阻止" class="sidebar-link">7. 事件冒泡、捕获和阻止</a></li><li class="sidebar-sub-header"><a href="/Front-end-go-on/pages/frontend/base/Js.html#_8-事件委托" class="sidebar-link">8. 事件委托</a></li><li class="sidebar-sub-header"><a href="/Front-end-go-on/pages/frontend/base/Js.html#_9-dom-事件中-currenttarget-和-target-的区别" class="sidebar-link">9. dom 事件中 currentTarget 和 target 的区别</a></li><li class="sidebar-sub-header"><a href="/Front-end-go-on/pages/frontend/base/Js.html#_10-script-中-defer-和-async-的区别" class="sidebar-link">10. script 中 defer 和 async 的区别</a></li><li class="sidebar-sub-header"><a href="/Front-end-go-on/pages/frontend/base/Js.html#_11-this-指向" class="sidebar-link">11. this 指向</a></li><li class="sidebar-sub-header"><a href="/Front-end-go-on/pages/frontend/base/Js.html#_12-事件执行机制" class="sidebar-link">12. 事件执行机制</a></li><li class="sidebar-sub-header"><a href="/Front-end-go-on/pages/frontend/base/Js.html#_13-js-继承方式总结" class="sidebar-link">13. jS 继承方式总结</a></li><li class="sidebar-sub-header"><a href="/Front-end-go-on/pages/frontend/base/Js.html#_14-原型和原型链" class="sidebar-link">14.原型和原型链</a></li><li class="sidebar-sub-header"><a href="/Front-end-go-on/pages/frontend/base/Js.html#_15-闭包" class="sidebar-link">15. 闭包</a></li><li class="sidebar-sub-header"><a href="/Front-end-go-on/pages/frontend/base/Js.html#_16-节流和防抖" class="sidebar-link">16. 节流和防抖</a></li><li class="sidebar-sub-header"><a href="/Front-end-go-on/pages/frontend/base/Js.html#_17-settimeout-和-setinterval-的运行机制" class="sidebar-link">17. setTimeout 和 setInterval 的运行机制</a></li><li class="sidebar-sub-header"><a href="/Front-end-go-on/pages/frontend/base/Js.html#_18-js循环" class="sidebar-link">18. JS循环</a></li><li class="sidebar-sub-header"><a href="/Front-end-go-on/pages/frontend/base/Js.html#_19-跨域是什么-怎么解决" class="sidebar-link">19. 跨域是什么，怎么解决</a></li><li class="sidebar-sub-header"><a href="/Front-end-go-on/pages/frontend/base/Js.html#_20-关于-js-的堆栈和拷贝" class="sidebar-link">20. 关于 JS 的堆栈和拷贝</a></li><li class="sidebar-sub-header"><a href="/Front-end-go-on/pages/frontend/base/Js.html#_21-内存泄漏是什么" class="sidebar-link">21. 内存泄漏是什么</a></li><li class="sidebar-sub-header"><a href="/Front-end-go-on/pages/frontend/base/Js.html#_22-web-安全" class="sidebar-link">22. WEB 安全</a></li><li class="sidebar-sub-header"><a href="/Front-end-go-on/pages/frontend/base/Js.html#_23-js创建对象的几种方式" class="sidebar-link">23. JS创建对象的几种方式</a></li><li class="sidebar-sub-header"><a href="/Front-end-go-on/pages/frontend/base/Js.html#_24-作用域链" class="sidebar-link">24. 作用域链</a></li><li class="sidebar-sub-header"><a href="/Front-end-go-on/pages/frontend/base/Js.html#_25-js-延迟加载的方式" class="sidebar-link">25. JS 延迟加载的方式</a></li><li class="sidebar-sub-header"><a href="/Front-end-go-on/pages/frontend/base/Js.html#_26-js-模块化方案" class="sidebar-link">26. JS 模块化方案</a></li><li class="sidebar-sub-header"><a href="/Front-end-go-on/pages/frontend/base/Js.html#_27-documen-write-和-innerhtml-的区别" class="sidebar-link">27. documen.write 和 innerHTML 的区别</a></li><li class="sidebar-sub-header"><a href="/Front-end-go-on/pages/frontend/base/Js.html#_28-v8下的垃圾回收机制" class="sidebar-link">28. V8下的垃圾回收机制</a></li><li class="sidebar-sub-header"><a href="/Front-end-go-on/pages/frontend/base/Js.html#_29-0-1-0-2-0-3" class="sidebar-link">29. 0.1 + 0.2 != 0.3</a></li><li class="sidebar-sub-header"><a href="/Front-end-go-on/pages/frontend/base/Js.html#_30-性能定义和性能优化" class="sidebar-link">30. 性能定义和性能优化</a></li><li class="sidebar-sub-header"><a href="/Front-end-go-on/pages/frontend/base/Js.html#_31-尾调用及其好处" class="sidebar-link">31. 尾调用及其好处</a></li><li class="sidebar-sub-header"><a href="/Front-end-go-on/pages/frontend/base/Js.html#_32-cookies-sessionstorage-和-localstorage-的区别" class="sidebar-link">32.cookies，sessionStorage 和 localStorage 的区别</a></li><li class="sidebar-sub-header"><a href="/Front-end-go-on/pages/frontend/base/Js.html#_33-​​indexeddb​​-以及-service-worker-cache-api​" class="sidebar-link">33.​​IndexedDB​​ 以及 Service Worker + Cache API​</a></li></ul></li><li><a href="/Front-end-go-on/pages/frontend/base/ES6.html" class="sidebar-link">ES6基础</a></li><li><a href="/Front-end-go-on/pages/frontend/base/Http.html" class="sidebar-link">HTTP基础</a></li><li><a href="/Front-end-go-on/pages/frontend/base/Cache.html" class="sidebar-link">前端缓存</a></li><li><a href="/Front-end-go-on/pages/frontend/base/Performance.html" class="sidebar-link">页面性能</a></li><li><a href="/Front-end-go-on/pages/frontend/base/Algorithm.html" class="sidebar-link">数据结构基础</a></li><li><a href="/Front-end-go-on/pages/frontend/base/MyArticle.html" class="sidebar-link">我的文章</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>前端进阶</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/Front-end-go-on/pages/frontend/frame/base/Vue.html" class="sidebar-link">Vue2基础</a></li><li><a href="/Front-end-go-on/pages/frontend/frame/advanced/Vue.html" class="sidebar-link">Vue2进阶</a></li><li><a href="/Front-end-go-on/pages/frontend/frame/base/Vue3.html" class="sidebar-link">Vue3基础</a></li><li><a href="/Front-end-go-on/pages/frontend/frame/base/React.html" class="sidebar-link">React基础</a></li><li><a href="/Front-end-go-on/pages/frontend/frame/advanced/React.html" class="sidebar-link">React进阶</a></li><li><a href="/Front-end-go-on/pages/frontend/frame/advanced/React18.html" class="sidebar-link">React18新特性</a></li><li><a href="/Front-end-go-on/pages/frontend/frame/base/VueVsReact.html" class="sidebar-link">Vue和React对比</a></li><li><a href="/Front-end-go-on/pages/frontend/frame/base/RN.html" class="sidebar-link">RN基础</a></li><li><a href="/Front-end-go-on/pages/frontend/frame/base/RNEnv.html" class="sidebar-link">RN环境搭建和打包</a></li><li><a href="/Front-end-go-on/pages/frontend/frame/base/Packaging.html" class="sidebar-link">打包工具</a></li><li><a href="/Front-end-go-on/pages/frontend/frame/base/Ts.html" class="sidebar-link">TS基础</a></li><li><a href="/Front-end-go-on/pages/frontend/frame/base/Nuxt.html" class="sidebar-link">Nuxt基础</a></li><li><a href="/Front-end-go-on/pages/frontend/frame/base/Applet.html" class="sidebar-link">小程序基础</a></li><li><a href="/Front-end-go-on/pages/frontend/frame/base/MicroFrontend.html" class="sidebar-link">微前端基础</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>前端代码练习</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/Front-end-go-on/pages/frontend/exercise/Css.html" class="sidebar-link">CSS代码练习</a></li><li><a href="/Front-end-go-on/pages/frontend/exercise/Js.html" class="sidebar-link">JS代码练习</a></li><li><a href="/Front-end-go-on/pages/frontend/exercise/Algorithm.html" class="sidebar-link">算法代码练习</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>前端代码技巧</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/Front-end-go-on/pages/frontend/skill/Tools.html" class="sidebar-link">工具库</a></li><li><a href="/Front-end-go-on/pages/frontend/skill/Utils.html" class="sidebar-link">工具函数</a></li><li><a href="/Front-end-go-on/pages/frontend/skill/CSSAnimation.html" class="sidebar-link">CSS动画库</a></li><li><a href="/Front-end-go-on/pages/frontend/skill/Css.html" class="sidebar-link">CSS代码技巧</a></li><li><a href="/Front-end-go-on/pages/frontend/skill/Js.html" class="sidebar-link">JS代码技巧</a></li><li><a href="/Front-end-go-on/pages/frontend/skill/Project.html" class="sidebar-link">项目技巧</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="_1-js-的数据类型"><a href="#_1-js-的数据类型" class="header-anchor">#</a> 1. JS 的数据类型</h2> <p><strong>6 种简单数据类型</strong>：<code>undefined</code>、<code>null</code>、<code>boolean</code>、<code>number</code>、<code>string</code> 和 <code>symbol(ES6) </code>(表示独一无二的值，可以保证属性不重名)<br> <strong>1 种复杂的数据类型</strong>：<code>Object</code></p> <p><strong>栈(stack)：原始数据类型</strong>：<code>String</code>，<code>Boolean</code>，<code>Number</code>，<code>Null</code>，<code>Undefined</code>占据空间小、大小固定
<strong>堆(heap)：引用数据类型</strong>：<code>Object(Array, Date, RegExp, Function)</code>占据空间大、大小不固定</p> <h4 id="boolean、number、string-这三个是-javascript-中的基本包装类型-也就是这三个其实是一个构造函数-他们是-function-的实例-是引用类型"><a href="#boolean、number、string-这三个是-javascript-中的基本包装类型-也就是这三个其实是一个构造函数-他们是-function-的实例-是引用类型" class="header-anchor">#</a> Boolean、Number、String 这三个是 Javascript 中的基本包装类型，也就是这三个其实是一个构造函数，他们是 Function 的实例，是引用类型</h4> <div class="custom-block warning"><p class="custom-block-title">WARNING</p> <p>需要注意的是 typeof null 返回为 object，因为特殊值 null 被认为是一个空的对象引用。undefined 值是派生自 null 值的，因此 ECMA-262 规定对它们的相等性测试要返回 true</p></div> <div class="language-js line-numbers-mode"><pre class="language-js"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">undefined</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//true</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h2 id="_2-tpyeof-可以返回多少种值"><a href="#_2-tpyeof-可以返回多少种值" class="header-anchor">#</a> 2. tpyeof 可以返回多少种值</h2> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token string">&quot;d&quot;</span><span class="token punctuation">;</span> <span class="token comment">// string</span>
<span class="token keyword">let</span> num <span class="token operator">=</span> <span class="token number">3232</span><span class="token punctuation">;</span> <span class="token comment">// number</span>
<span class="token keyword">let</span> str <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">&quot;dd&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// object</span>
<span class="token keyword">let</span> un <span class="token operator">=</span> <span class="token keyword">undefined</span><span class="token punctuation">;</span> <span class="token comment">// undefined</span>
<span class="token keyword">let</span> bool <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token comment">// boolean</span>
<span class="token keyword">function</span> <span class="token function">aa</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment">// function</span>
<span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token string">&quot;sym&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// symbol (ES6)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h2 id="_3-js-中-new-一个对象会发生什么"><a href="#_3-js-中-new-一个对象会发生什么" class="header-anchor">#</a> 3. JS 中 new 一个对象会发生什么</h2> <p>当执行 <code>const obj = new MyClass()</code> 时，会发生以下过程：</p> <ul><li>3.1 创建一个空对象</li></ul> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// 或更底层：obj = Object.create(MyClass.prototype);</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><ul><li>3.2 绑定原型（Prototype Link）</li></ul> <p>将新对象的 <code>__proto__</code>(隐式原型) 指向构造函数的 <code>prototype</code>(显式原型) 属性</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>obj<span class="token punctuation">.</span>__proto__ <span class="token operator">=</span> <span class="token class-name">MyClass</span><span class="token punctuation">.</span>prototype<span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><ul><li>3.3 执行构造函数（绑定 this）</li></ul> <p>调用构造函数 <code>MyClass</code>，并将 <code>this</code> 指向新创建的对象：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token function">MyClass</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 构造函数内部的 this 就是 obj</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><ul><li>3.4 处理返回值</li></ul> <p>如果构造函数 <strong>返回一个对象</strong>（如 <code>return { foo: 1 }</code>），则 <strong>new</strong> 的结果是这个对象。</p> <p>如果返回 <strong>非对象值</strong>（如 <code>return 1</code>），则忽略返回值，仍然返回新创建的对象 <strong>obj</strong>。</p> <h4 id="手动实现的-new-操作符逻辑"><a href="#手动实现的-new-操作符逻辑" class="header-anchor">#</a> 手动实现的 new 操作符逻辑</h4> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">myNew</span><span class="token punctuation">(</span><span class="token parameter">constructor<span class="token punctuation">,</span> <span class="token operator">...</span>args</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 1. 创建空对象并绑定原型</span>
  <span class="token keyword">const</span> obj <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>constructor<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// 2. 执行构造函数（绑定 this）</span>
  <span class="token keyword">const</span> result <span class="token operator">=</span> <span class="token function">constructor</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// 3. 处理返回值</span>
  <span class="token keyword">return</span> result <span class="token keyword">instanceof</span> <span class="token class-name">Object</span> <span class="token operator">?</span> result <span class="token operator">:</span> obj<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 使用示例</span>
<span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token function">myNew</span><span class="token punctuation">(</span>MyClass<span class="token punctuation">,</span> arg1<span class="token punctuation">,</span> arg2<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><div class="custom-block warning"><p class="custom-block-title">WARNING</p> <p>箭头函数不能作为构造函数</p></div> <p>箭头函数没有 this 绑定和 prototype 属性，因此不能 new：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token function-variable function">Foo</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">new</span> <span class="token class-name">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// TypeError: Foo is not a constructor</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h2 id="_4-预解析"><a href="#_4-预解析" class="header-anchor">#</a> 4. 预解析</h2> <p>预解析是 JavaScript 引擎在执行代码前的一个预处理阶段，它会将变量和函数声明提升到当前作用域的顶部。</p> <h4 id="_4-1-预解析的基本表现"><a href="#_4-1-预解析的基本表现" class="header-anchor">#</a> 4.1 预解析的基本表现</h4> <ul><li>变量声明提升（var）</li></ul> <div class="language-js line-numbers-mode"><pre class="language-js"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出: undefined</span>
<span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出: 5</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>实际执行顺序相当于：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">var</span> a<span class="token punctuation">;</span>          <span class="token comment">// 声明提升到作用域顶部</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 此时a已声明但未赋值</span>
a <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>          <span class="token comment">// 赋值保留在原位置</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><ul><li>函数声明提升</li></ul> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出: &quot;Hello&quot;</span>

<span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;Hello&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>函数声明整体被提升到作用域顶部。</p> <h4 id="_4-2-不同声明方式的预解析差异"><a href="#_4-2-不同声明方式的预解析差异" class="header-anchor">#</a> 4.2 不同声明方式的预解析差异</h4> <table><thead><tr><th style="text-align:center;">声明方式</th> <th style="text-align:center;">提升表现</th> <th style="text-align:center;">示例</th></tr></thead> <tbody><tr><td style="text-align:center;">var</td> <td style="text-align:center;">声明提升，值为undefined</td> <td style="text-align:center;">console.log(x); var x = 5;</td></tr> <tr><td style="text-align:center;">function</td> <td style="text-align:center;">整个函数体提升</td> <td style="text-align:center;">foo(); function foo() {}</td></tr> <tr><td style="text-align:center;">let/const</td> <td style="text-align:center;">提升但存在&quot;暂时性死区&quot;</td> <td style="text-align:center;">console.log(y); let y = 5; → 报错</td></tr> <tr><td style="text-align:center;">函数表达式</td> <td style="text-align:center;">按变量提升规则处理</td> <td style="text-align:center;">bar(); var bar = function() {} → 报错</td></tr></tbody></table> <h4 id="_4-3-预解析的优先级规则"><a href="#_4-3-预解析的优先级规则" class="header-anchor">#</a> 4.3 预解析的优先级规则</h4> <p>函数声明优先于变量声明</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> foo<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出: &quot;function&quot;</span>

<span class="token keyword">var</span> foo<span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>后面的函数声明会覆盖前面的</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出: &quot;Second&quot;</span>

<span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;First&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;Second&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h4 id="_4-4-let-const-的暂时性死区-tdz"><a href="#_4-4-let-const-的暂时性死区-tdz" class="header-anchor">#</a> 4.4 let/const 的暂时性死区(TDZ)</h4> <p>虽然 <code>let</code> 和 <code>const</code> 也会被提升，但在声明前访问会报错：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ReferenceError: Cannot access 'b' before initialization</span>
<span class="token keyword">let</span> b <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h4 id="_4-5-实际开发中的注意事项"><a href="#_4-5-实际开发中的注意事项" class="header-anchor">#</a> 4.5 实际开发中的注意事项</h4> <ul><li><ol><li>避免先使用后声明：虽然预解析允许，但会降低代码可读性</li></ol></li> <li><ol start="2"><li>使用函数表达式时注意：</li></ol></li></ul> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// 这样会报错</span>
<span class="token function">myFunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token keyword">var</span> <span class="token function-variable function">myFunc</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 正确方式</span>
<span class="token keyword">var</span> <span class="token function-variable function">myFunc</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token function">myFunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><ul><li><ol start="3"><li>推荐使用 let/const：避免 var 的提升问题</li></ol></li></ul> <h2 id="_5-call、apply-和-bind-的理解"><a href="#_5-call、apply-和-bind-的理解" class="header-anchor">#</a> 5. call、apply 和 bind 的理解</h2> <h4 id="call、apply-和-bind-是-function-对象自带的三个方法-属于对象冒充-可以调用另外一个对象的方法-同时改变函数体内部-this-的指向。"><a href="#call、apply-和-bind-是-function-对象自带的三个方法-属于对象冒充-可以调用另外一个对象的方法-同时改变函数体内部-this-的指向。" class="header-anchor">#</a> call、apply 和 bind 是 Function 对象自带的三个方法，属于对象冒充，可以调用另外一个对象的方法，同时改变函数体内部 this 的指向。</h4> <table><thead><tr><th style="text-align:center;">方法</th> <th style="text-align:center;">调用时机</th> <th style="text-align:center;">参数传递方式</th> <th style="text-align:center;">返回值</th></tr></thead> <tbody><tr><td style="text-align:center;">call</td> <td style="text-align:center;">立即调用</td> <td style="text-align:center;">单独传递</td> <td style="text-align:center;">函数执行结果</td></tr> <tr><td style="text-align:center;">apply</td> <td style="text-align:center;">立即调用</td> <td style="text-align:center;">数组形式传递</td> <td style="text-align:center;">函数执行结果</td></tr> <tr><td style="text-align:center;">bind</td> <td style="text-align:center;">不立即调用</td> <td style="text-align:center;">单独传递或部分传递</td> <td style="text-align:center;">绑定后的新函数</td></tr></tbody></table> <h4 id="自己动手实现-call-方法"><a href="#自己动手实现-call-方法" class="header-anchor">#</a> 自己动手实现 call 方法</h4> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token class-name">Function</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">myCall</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">context<span class="token punctuation">,</span> <span class="token operator">...</span>arg</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> obj <span class="token operator">=</span> context <span class="token operator">||</span> window<span class="token punctuation">;</span>
  obj<span class="token punctuation">.</span>fn <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> result <span class="token operator">=</span> obj<span class="token punctuation">.</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token operator">...</span>arg<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">delete</span> obj<span class="token punctuation">.</span>fn<span class="token punctuation">;</span>
  <span class="token keyword">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h4 id="自己动手实现-apply-方法"><a href="#自己动手实现-apply-方法" class="header-anchor">#</a> 自己动手实现 apply 方法</h4> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token class-name">Function</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">myApply</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">context<span class="token punctuation">,</span> arg</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> obj <span class="token operator">=</span> context <span class="token operator">||</span> window<span class="token punctuation">;</span>
  obj<span class="token punctuation">.</span>fn <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> res<span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    res <span class="token operator">=</span> obj<span class="token punctuation">.</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token operator">...</span>arg<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    res <span class="token operator">=</span> obj<span class="token punctuation">.</span>fn<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">delete</span> obj<span class="token punctuation">.</span>fn<span class="token punctuation">;</span>
  <span class="token keyword">return</span> res<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><h4 id="实际应用场景"><a href="#实际应用场景" class="header-anchor">#</a> 实际应用场景</h4> <ul><li>1.借用方法：使用其他对象的方法</li></ul> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">const</span> obj1 <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'obj1'</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> obj2 <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'obj2'</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">showName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">showName</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>obj1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &quot;obj1&quot;</span>
<span class="token function">showName</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>obj2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &quot;obj2&quot;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><ul><li>2.类数组转为数组</li></ul> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">list</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><ul><li>3.延迟执行（bind）</li></ul> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">const</span> button <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'button'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
button<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">handleClick</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h2 id="_6-事件绑定-3-种方法"><a href="#_6-事件绑定-3-种方法" class="header-anchor">#</a> 6. 事件绑定 3 种方法</h2> <p><strong>1、HTML 事件处理(在 dom 元素中嵌入)</strong></p> <div class="language-html line-numbers-mode"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token special-attr"><span class="token attr-name">onclick</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span><span class="token value javascript language-javascript"><span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span><span class="token punctuation">&quot;</span></span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><div class="custom-block warning"><p class="custom-block-title">WARNING</p> <ul><li>缺点：<br>
1、this 指向 window<br>
2、HTML 与 JS 紧密耦合，改动代码麻烦</li></ul></div> <p><strong>2、DOM0 级事件处理(获取 dom 元素直接绑定)</strong></p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">&quot;btn&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span>onclick <span class="token operator">=</span> fn<span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><div class="custom-block warning"><p class="custom-block-title">WARNING</p> <ul><li>优点：<br>
1、this 指向 dom 元素<br>
2、不存在浏览器兼容问题</li></ul></div> <p><strong>3、DOM2 级事件处理(事件监听)</strong></p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">&quot;btn&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">&quot;click&quot;</span><span class="token punctuation">,</span> fn<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><div class="custom-block warning"><p class="custom-block-title">WARNING</p> <ul><li>优点：<br>
1、this 指向 dom 元素</li> <li>缺点：<br>
1、需要对 IE8 及以下进行兼容</li></ul></div> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>tip: document.getElementById('btn').attachEvent('click',fn)<br>
由于 IE8 及以下只支持事件冒泡，所以通过 attachEvent 都会被添加到冒泡阶段<br>
IE 中的 attachEvent 中的 this 总是指向全局对象 Window</p></div> <h2 id="_7-事件冒泡、捕获和阻止"><a href="#_7-事件冒泡、捕获和阻止" class="header-anchor">#</a> 7. 事件冒泡、捕获和阻止</h2> <h4 id="事件冒泡-即事件开始时由最具体的元素-文档中嵌套层数最深的那个点-接收-然后逐级向上传播到较为不具体的节点-文档"><a href="#事件冒泡-即事件开始时由最具体的元素-文档中嵌套层数最深的那个点-接收-然后逐级向上传播到较为不具体的节点-文档" class="header-anchor">#</a> 事件冒泡：即事件开始时由最具体的元素(文档中嵌套层数最深的那个点)接收，然后逐级向上传播到较为不具体的节点(文档)</h4> <blockquote><p>由 div -&gt; body -&gt; html -&gt; document</p></blockquote> <h4 id="事件捕获-不太具体的节点应该更早接收到事件-而最具体的节点应该最后接收到事件"><a href="#事件捕获-不太具体的节点应该更早接收到事件-而最具体的节点应该最后接收到事件" class="header-anchor">#</a> 事件捕获：不太具体的节点应该更早接收到事件，而最具体的节点应该最后接收到事件</h4> <blockquote><p>由 document -&gt; html -&gt; body -&gt; div</p></blockquote> <p>因为老版本的不支持，因此很少会用事件捕获,多数在事件冒泡下处理程序</p> <p><strong>DOM2 级规定的事件流包括三个阶段：事件捕获阶段、处于目标阶段、事件冒泡阶段</strong></p> <h4 id="阻止事件冒泡-event-stoppropagation"><a href="#阻止事件冒泡-event-stoppropagation" class="header-anchor">#</a> 阻止事件冒泡：event.stopPropagation()</h4> <p>一个阻止事件冒泡的办法就是使用 event.stopPropagation()<br>
在 IE&lt;9 的浏览器上使用 event.cancelBubble = true</p> <h4 id="取消事件的默认行为-preventdefault"><a href="#取消事件的默认行为-preventdefault" class="header-anchor">#</a> 取消事件的默认行为：preventDefault()</h4> <p>1、在其他浏览器中调用方法 e.preventDefault()<br>
2、在 IE 浏览器中通过 e.returnValue = false</p> <h4 id="当-return-false-的时候"><a href="#当-return-false-的时候" class="header-anchor">#</a> 当 return false“的时候</h4> <p>在 DOM0 级事件中，可以像 event.preventDefault() 取消默认事件，但是在 DOM2 级则不行</p> <h4 id="stopimmediatepropagation"><a href="#stopimmediatepropagation" class="header-anchor">#</a> stopImmediatePropagation()</h4> <p>这个方法会停止一个事件继续执行，即使当前的对象上还绑定了其它处理函数<br>
所有绑定在一个对象上的事件会按绑定顺序执行</p> <h2 id="_8-事件委托"><a href="#_8-事件委托" class="header-anchor">#</a> 8. 事件委托</h2> <p>也叫事件代理</p> <ul><li>好处：
节省内存：每个函数都是一个对象，是对象就会占用内存，对象越多，内存占用率就越大<br>
不需要为每个子节点注销事件<br>
不知道子节点的具体数量时(下拉加载图片)</li> <li>原理：<br>
事件委托是利用事件的冒泡原理来实现的<br>
通过 e.target 获取具体子元素</li></ul> <h2 id="_9-dom-事件中-currenttarget-和-target-的区别"><a href="#_9-dom-事件中-currenttarget-和-target-的区别" class="header-anchor">#</a> 9. dom 事件中 currentTarget 和 target 的区别</h2> <ul><li>本质区别是：<br>
event.target 返回触发事件的元素<br>
event.currentTarget 返回绑定事件的元素</li></ul> <div class="language-html line-numbers-mode"><pre class="language-html"><code><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token special-attr"><span class="token attr-name">style</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span><span class="token value css language-css"><span class="token property">width</span><span class="token punctuation">:</span> 30px<span class="token punctuation">;</span><span class="token property">height</span><span class="token punctuation">:</span> 30px<span class="token punctuation">;</span><span class="token property">background-color</span><span class="token punctuation">:</span> #0e91e1</span><span class="token punctuation">&quot;</span></span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
    document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">&quot;body&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function-variable function">onclick</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;currentTarget:&quot;</span><span class="token punctuation">,</span> e<span class="token punctuation">.</span>currentTarget<span class="token punctuation">)</span><span class="token punctuation">;</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;target:&quot;</span><span class="token punctuation">,</span> e<span class="token punctuation">.</span>target<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
  </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span>

点击div时: currentTarget: body target: div 点击body时: currentTarget: body
target: body
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><h2 id="_10-script-中-defer-和-async-的区别"><a href="#_10-script-中-defer-和-async-的区别" class="header-anchor">#</a> 10. script 中 defer 和 async 的区别</h2> <p><a href="https://www.growingwiththeweb.com/2014/02/async-vs-defer-attributes.html" target="_blank" rel="noopener noreferrer">参考：<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><strong>script</strong>：会阻碍 HTML 解析，只有下载好并执行完脚本才会继续解析 HTML。<br> <strong>async script</strong>：解析 HTML 过程中进行脚本的异步下载，下载成功立马执行，有可能会阻断 HTML 的解析。<br> <strong>defer script</strong>：完全不会阻碍 HTML 的解析，解析完成之后再按照顺序执行脚本。</p> <img src="/Front-end-go-on/assets/img/script.b8648635.jpg"> <ul><li>defer 和 async 都是只适用于外部的脚本文件，都是用来告诉浏览器立即下载文件，但是延迟执行</li> <li>这些脚本文件会等到 body 的内容执行完才执行<br>
在 HTML5 的规范中，defer 属性要求脚本是按照出现的先后顺序执行，但是在现实中，defer 属性的脚本不一定会按照顺序执行<br>
而 async 属性的脚本执行的顺序并不确定</li></ul> <div class="language-html line-numbers-mode"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">async</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>1.js<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span> <span class="token comment">&lt;!-- 可能最后执行 --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">defer</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>2.js<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span> <span class="token comment">&lt;!-- 保证第二个执行 --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>3.js<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>      <span class="token comment">&lt;!-- 最先执行 --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">defer</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>4.js<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span> <span class="token comment">&lt;!-- 保证最后执行 --&gt;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h2 id="_11-this-指向"><a href="#_11-this-指向" class="header-anchor">#</a> 11. this 指向</h2> <ul><li>在普通函数中，this 的指向在函数定义的时候是确定不了的，只有函数执行的时候才能确定 this 到底指向谁，实际上 this 的最终指向的是那个调用它的对象</li> <li>在箭头函数中，this 的指向是定义时所在的对象，而不是使用时所在的对象</li></ul> <h2 id="_12-事件执行机制"><a href="#_12-事件执行机制" class="header-anchor">#</a> 12. 事件执行机制</h2> <ul><li><p>javascript 是一门单线程语言<br>
JS 在执行的过程中会产生执行环境，这些执行环境会被按照顺序的加入到执行栈中<br>
同步和异步任务分别进入不同的执行&quot;场所&quot;，同步的进入主线程，异步的代码，会被挂起并加入到 Task（有多种 task） 队列中</p></li> <li><p>除了广义的同步任务和异步任务，还包括有更加精确的微任务和宏任务<br> <strong>微任务</strong>包括 process.nextTick，promise，Object.observe，MutationObserver<br> <strong>宏任务</strong>包括 script，setTimeout，setInterval，setImmediate，I/O，UI rendering</p></li> <li><p>为什么需要微任务：是为了给紧急任务一个插队的机会</p></li></ul> <p>当前宏任务中的 JavaScript 快执行完成时，也就在 JavaScript 引擎准备退出全局执行上下文并清空调用栈的时候，JavaScript 引擎会检查全局执行上下文中的微任务队列，然后按照顺序执行队列中的微任务。</p> <ul><li>所以正确的一次 Event loop 顺序是这样的<br>
1.执行同步代码，这属于宏任务<br>
2.执行栈为空，查询是否有微任务需要执行<br>
3.执行所有微任务<br>
4.必要的话渲染 UI<br>
5.然后开始下一轮 Event loop，执行宏任务中的异步代码</li></ul> <div class="language-js line-numbers-mode"><pre class="language-js"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 
<span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token parameter">resolve</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'b'</span><span class="token punctuation">)</span>
    <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'c'</span><span class="token punctuation">)</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'d'</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
 
<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'e'</span><span class="token punctuation">)</span>
    <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token parameter">resolve</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'f'</span><span class="token punctuation">)</span>
        <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'g'</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span>
 
<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'h'</span><span class="token punctuation">)</span>
    <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token parameter">resolve</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'i'</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'j'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br></div></div><ul><li>上述代码执行结果：a b c h j i d e f g</li></ul> <p>1.打印a<br>
2.promise立即执行，打印b<br>
3.promise.then推入微任务队列<br>
4.setTimeout推入宏任务队列<br>
5.整段代码执行完毕，开始执行微任务，打印c，遇到setTimeout推入宏任务队列排队等待执行<br>
6.没有可执行的微任务开始执行宏任务，定时器按照延迟时间排队执行<br>
7.打印h j，promise.then推入微任务队列有<br>
8.可执行的微任务，打印i，继续执行宏任务，打印d<br>
9.执行延迟为100的宏任务，打印e f，执行微任务打印g，所有任务执行完毕</p> <h2 id="_13-js-继承方式总结"><a href="#_13-js-继承方式总结" class="header-anchor">#</a> 13. jS 继承方式总结</h2> <p><a href="http://cavszhouyou.top/JavaScript%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%B9%8B%E7%BB%A7%E6%89%BF.html" target="_blank" rel="noopener noreferrer">参考<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>一共6种，构造函数、原型链继承、组合继承、寄生式继承、寄生式组合继承、ES6继承</p> <ul><li>借用构造函数继承</li></ul> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Parent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">Children</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">Parent</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 或apply</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>缺点：父类原型上的东西是没法继承的，因此函数复用也就无从谈起</p> <ul><li>原型链继承</li></ul> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Parent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">Children</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token class-name">Children</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Parent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>这种方式确实解决了上面借用构造函数继承方式的缺点<br>
但是，这种方式仍有缺点:实例化了两个 Child 原型链上中的原型对象它俩是共用的</p> <ul><li>组合继承</li></ul> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Parent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">Children</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token class-name">Children</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token class-name">Parent</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Children</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> Children<span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><ul><li>寄生式继承</li></ul> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">createAnother</span><span class="token punctuation">(</span><span class="token parameter">original</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">var</span> clone <span class="token operator">=</span> <span class="token function">object</span><span class="token punctuation">(</span>original<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//通过调用函数创建一个新对象</span>
    clone<span class="token punctuation">.</span><span class="token function-variable function">sayHi</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment">// 某种方式增强这个对象</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;hi&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> clone<span class="token punctuation">;</span>  <span class="token comment">// 返回这个对象</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> person <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">&quot;james&quot;</span><span class="token punctuation">}</span>
<span class="token keyword">var</span> anotherPerson <span class="token operator">=</span> <span class="token function">createAnother</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span><span class="token punctuation">;</span>

anotherPerson<span class="token punctuation">.</span><span class="token function">sayHi</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &quot;hi&quot;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>优点：在主要考虑对象而不是自定义类型和构造函数的情况下，实现简单的继承。<br>
缺点：使用该继承方式，在为对象添加函数的时候，没有办法做到函数的复用。</p> <ul><li>ES6 继承</li></ul> <p>Class 可以通过 extends 关键字实现继承</p> <h2 id="_14-原型和原型链"><a href="#_14-原型和原型链" class="header-anchor">#</a> 14.原型和原型链</h2> <h4 id="prototype-属性"><a href="#prototype-属性" class="header-anchor">#</a> prototype 属性：</h4> <p>这是一个显式原型属性，只有函数才拥有该属性。</p> <h4 id="proto-属性"><a href="#proto-属性" class="header-anchor">#</a> <em>proto</em> 属性：</h4> <p>这是每个对象都有的隐式原型属性，指向了创建该对象的构造函数的原型。</p> <h4 id="什么是原型链"><a href="#什么是原型链" class="header-anchor">#</a> 什么是原型链：</h4> <ul><li>原型链：实例与原型之间的链接</li></ul> <p>由于 <code><strong>proto</strong></code> 是任何对象都有的属性，而 js 里万物都是对象，所以会形成一条<code><strong>proto</strong></code>连起来的链条，递归访问<code><strong>proto</strong></code>必须最终到头，并且值是<code>null</code>。</p> <p>在寻找对象方法的时候，会先寻找自身的方法，如果没有，就会通过<code><strong>proto</strong></code>去寻找该构造函数原型上的方法，如果没有，就会进一步寻找 <code>Object</code>原型上的方法，直到最后指向<code>null</code>。像这样通过<code><strong>proto</strong></code>连起来的链条寻找 prototype 就叫原型链</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">var</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
p<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> <span class="token class-name">Person</span><span class="token punctuation">.</span>prototype <span class="token comment">// true</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h4 id="js-获取原型的方法"><a href="#js-获取原型的方法" class="header-anchor">#</a> js 获取原型的方法</h4> <div class="language-js line-numbers-mode"><pre class="language-js"><code>p<span class="token punctuation">.</span>__proto__
p<span class="token punctuation">.</span>constructor<span class="token punctuation">.</span>prototype
Object<span class="token punctuation">.</span><span class="token function">getPrototypeOf</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><br> <img src="/Front-end-go-on/assets/img/proto.622d3b1f.png" alt="原型和原型链"> <h2 id="_15-闭包"><a href="#_15-闭包" class="header-anchor">#</a> 15. 闭包</h2> <ul><li>1、概念：有权访问另一个函数作用域和变量的函数，创建闭包最简单的方式就是在一个函数内部创建另一个函数。</li></ul> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">outer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">function</span> <span class="token function">inner</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">inner</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1</span>
<span class="token punctuation">}</span>
<span class="token function">outer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><ul><li>2、好处：由于可以读取函数内部的变量，如果希望一个变量常驻于内存中又可全局访问，同时又想避免全局变量的污染，此时使用闭包就是一种恰当的方式</li> <li>3、缺点：但正是因为函数内部变量被外部所引用，不会被垃圾回收，就会造成常驻内存，使用过多容易造成内存泄漏</li></ul> <h2 id="_16-节流和防抖"><a href="#_16-节流和防抖" class="header-anchor">#</a> 16. 节流和防抖</h2> <ul><li>防抖和节流的作用都是防止函数多次调用
区别在于，假设一个用户一直触发这个函数，且每次触发函数的间隔小于 wait，防抖的情况下只会调用一次（你越点我，我就越不执行）<br>
而节流的 情况会每隔一定时间（参数 wait）调用函数。</li></ul> <h4 id="手写防抖"><a href="#手写防抖" class="header-anchor">#</a> 手写防抖</h4> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">debounce</span><span class="token punctuation">(</span><span class="token parameter">fn<span class="token punctuation">,</span> wait <span class="token operator">=</span> <span class="token number">1000</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> timeout <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>args</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>timeout<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">clearTimeout</span><span class="token punctuation">(</span>timeout<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    timeout <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> wait<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><h4 id="手写节流"><a href="#手写节流" class="header-anchor">#</a> 手写节流</h4> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">throttle</span><span class="token punctuation">(</span><span class="token parameter">fn<span class="token punctuation">,</span> wait <span class="token operator">=</span> <span class="token number">1000</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> timeout <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>timeout<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      timeout <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        timeout <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span> wait<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><h2 id="_17-settimeout-和-setinterval-的运行机制"><a href="#_17-settimeout-和-setinterval-的运行机制" class="header-anchor">#</a> 17. setTimeout 和 setInterval 的运行机制</h2> <p>setTimeout() 和 setInterval() 都是属于定时器，同属于 window 方法，所以 this 会指向 window，它们的区别在于 setTimeout 只调用一次，而 setInterval 是重复调用。它们两者都是属于异步机制，属于宏任务，只是在指定的时间里将要执行的内容放到任务队列里。</p> <ul><li>使用 setInterval 会出现两个问题<br>
(1) 某些时间间隔会被跳过<br>
(2) 多个定时器代码的执行之间的间隔可能会比预期的小</li></ul> <h4 id="​​用-settimeout-实现-setinterval-的功能​"><a href="#​​用-settimeout-实现-setinterval-的功能​" class="header-anchor">#</a> ​​用 <code>setTimeout</code> 实现 <code>setInterval</code> 的功能​</h4> <p>代码实现</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">mySetInterval</span><span class="token punctuation">(</span><span class="token parameter">callback<span class="token punctuation">,</span> delay</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> timerId<span class="token punctuation">;</span>

  <span class="token comment">// 定义递归函数</span>
  <span class="token keyword">const</span> <span class="token function-variable function">execute</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token function">callback</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment">// 执行回调</span>
    timerId <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span>execute<span class="token punctuation">,</span> delay<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 递归调用</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>

  <span class="token comment">// 第一次启动</span>
  timerId <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span>execute<span class="token punctuation">,</span> delay<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// 返回一个清除定时器的方法</span>
  <span class="token keyword">return</span> <span class="token punctuation">{</span>
    <span class="token function-variable function">clear</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token function">clearTimeout</span><span class="token punctuation">(</span>timerId<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><p>使用示例</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// 定义一个回调函数</span>
<span class="token keyword">function</span> <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;Hello!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 使用自定义的 mySetInterval</span>
<span class="token keyword">const</span> interval <span class="token operator">=</span> <span class="token function">mySetInterval</span><span class="token punctuation">(</span>sayHello<span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 5秒后停止</span>
<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  interval<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;Interval stopped!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">5000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><h4 id="对比-setinterval-和-settimeout-实现​"><a href="#对比-setinterval-和-settimeout-实现​" class="header-anchor">#</a> 对比 setInterval 和 setTimeout 实现​</h4> <table><thead><tr><th style="text-align:center;">​​特性</th> <th style="text-align:center;">setInterval</th> <th style="text-align:center;">setTimeout 递归实现</th></tr></thead> <tbody><tr><td style="text-align:center;">​​执行机制​</td> <td style="text-align:center;">固定间隔执行，可能堆积</td> <td style="text-align:center;">前一次执行完才安排下一次</td></tr> <tr><td style="text-align:center;">​​误差累积​</td> <td style="text-align:center;">可能累积延迟（如回调执行时间较长）</td> <td style="text-align:center;">无累积误差</td></tr> <tr><td style="text-align:center;">​​可控性​</td> <td style="text-align:center;">只能 clearInterval</td> <td style="text-align:center;">可动态调整 delay 或停止</td></tr> <tr><td style="text-align:center;">​​内存泄漏风险​</td> <td style="text-align:center;">不清理会导致持续执行</td> <td style="text-align:center;">可手动清理</td></tr></tbody></table> <h2 id="_18-js循环"><a href="#_18-js循环" class="header-anchor">#</a> 18. JS循环</h2> <ul><li>1、最早遍历数组的方法：for</li></ul> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><ul><li>2、ES5 的 forEach 遍历数组</li></ul> <div class="language-js line-numbers-mode"><pre class="language-js"><code>arr<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">item<span class="token punctuation">,</span> index</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><div class="custom-block warning"><p class="custom-block-title">WARNING</p> <p>但是你不能使用 break 和 return 来退出循环</p></div> <ul><li>3、ES5 的 for-in 循环</li></ul> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> key <span class="token keyword">in</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//string</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><ul><li>4、ES6 的 for-of 循环</li></ul> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> key <span class="token keyword">of</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>for in 是 ES5 标准，遍历 key，for of 是 ES6 标准，遍历 value<br>
推荐在循环对象属性的时候，使用 for...in,在遍历数组的时候的时候使用 for...of
for...of 不能循环普通的对象，需要通过和 Object.keys()搭配使用</p> <ul><li><p><strong>for in 遍历数组是一个糟糕的选择</strong><br>
1.index 索引为字符串型数字，不能直接进行几何运算<br>
2.遍历顺序有可能不是按照实际数组的内部顺序<br>
3.使用 for in 会遍历数组所有的可枚举属性，包括原型。例如上栗的原型方法 method 和 name 属性。 所以 for in 更适合遍历对象，不要使用 for in 遍历数组<br>
4.for-in 这个代码是为普通对象设计的,不适用于数组的遍历</p></li> <li><p><strong>for of 用于遍历数组</strong><br>
for..of 适用遍历数/数组对象/字符串/map/set 等拥有迭代器对象的集合.但是不能遍历对象,因为没有迭代器对象.与 forEach()不同的是，它可以正确响应 break、continue 和 return 语句<br>
for-of 循环不支持普通对象，但如果你想迭代一个对象的属性，你可以用 for-in 循环（这也是它的本职工作）或内建的 Object.keys()方法：</p></li></ul> <h2 id="_19-跨域是什么-怎么解决"><a href="#_19-跨域是什么-怎么解决" class="header-anchor">#</a> 19. 跨域是什么，怎么解决</h2> <p>跨域指的是浏览器出于安全考虑的同源策略，当从一个地址向另外一个地址请求资源时，协议、域名、端口号任意一个不同都属于跨域</p> <ul><li><p>什么是同源策略
同源策略是浏览器的一个安全功能，不同源的客户端脚本在没有明确授权的情况下，不能读写对方资源。</p></li> <li><p>解决方法</p></li></ul> <h4 id="_1、-jsonp-json-with-padding"><a href="#_1、-jsonp-json-with-padding" class="header-anchor">#</a> 1、 JSONP(JSON With Padding):</h4> <div class="language- line-numbers-mode"><pre class="language-text"><code>JSONP 实现跨域请求的原理简单的说，就是利用&lt;script&gt;的 src 不受同源策略约束来跨域获取数据
jsonp 只支持 get 请求而不支持 post 请求
JSONP 的优势在于支持老式浏览器，以及可以向不支持 CORS 的网站请求数据。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h4 id="_2、cors-全称是-跨域资源共享-cross-origin-resource-sharing"><a href="#_2、cors-全称是-跨域资源共享-cross-origin-resource-sharing" class="header-anchor">#</a> 2、CORS (全称是&quot;跨域资源共享&quot;（Cross-origin resource sharing）):</h4> <p>参考：https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS
CORS 原理：使用自定义的 HTTP 头部让浏览器和服务器沟通<br>
如添加一个额外的 Origin 头部，包含请求页面的的地址信息（协议、域名、端口号）<br>
在后台设置 Access-Control-Allow-Origin 即可</p> <h5 id="cors-预检请求"><a href="#cors-预检请求" class="header-anchor">#</a> CORS 预检请求：</h5> <p>使用 OPTIONS 方法发起一个预检请求到服务器，以获知服务器是否允许该实际请求。<br>
&quot;预检请求“的使用，可以避免跨域请求对服务器的用户数据产生未预期的影响。</p> <h5 id="简单请求"><a href="#简单请求" class="header-anchor">#</a> 简单请求：</h5> <p>某些请求不会触发 CORS 预检请求。本文称这样的请求为“简单请求”</p> <ul><li>满足简单请求的条件：<br>
1、请求为 GET、HEAD、POST 其一<br>
2、请求字段满足 CORS 安全集合的字段<br>
3、Content-Type 有限制</li></ul> <div class="language-php line-numbers-mode"><pre class="language-php"><code><span class="token comment">// 允许访问源</span>
<span class="token function">header</span><span class="token punctuation">(</span><span class="token string single-quoted-string">'Access-Control-Allow-Origin:\*'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 允许访问的有效期</span>
<span class="token function">header</span><span class="token punctuation">(</span><span class="token string single-quoted-string">'Access-Control-Max-Age:86400'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 允许访问的方法</span>
<span class="token function">header</span><span class="token punctuation">(</span><span class="token string single-quoted-string">'Access-Control-Allow-Methods:OPTIONS, GET, POST, DELETE'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><ul><li>其他跨域：
document.domain + iframe 跨域<br>
window.name + iframe 跨域<br>
html5 的 postMessage<br>
img 的 src 属性、link 的 href 属性、script 的 src 属性<br>
websocket</li></ul> <h2 id="_20-关于-js-的堆栈和拷贝"><a href="#_20-关于-js-的堆栈和拷贝" class="header-anchor">#</a> 20. 关于 JS 的堆栈和拷贝</h2> <h4 id="_1、栈-stack-和堆-heap"><a href="#_1、栈-stack-和堆-heap" class="header-anchor">#</a> 1、栈(stack)和堆(heap)</h4> <p>stack 为自动分配的内存空间，它由系统自动释放<br>
而 heap 则是动态分配的内存，大小不定也不会自动释放</p> <h4 id="_2、基本类型和引用类型"><a href="#_2、基本类型和引用类型" class="header-anchor">#</a> 2、基本类型和引用类型</h4> <p>基本类型：存放在栈内存中的简单数据段，数据大小确定，内存空间大小可以分配<br>
5 种基本数据类型有 Undefined、Null、Boolean、Number 和 String，它们是直接按值存放的，所以可以直接访问。<br>
引用类型：存放在堆内存中的对象，变量实际保存的是一个指针，这个指针指向另一个位置。每个空间大小不一样，要根据情况开进行特定的分配。<br>
当我们需要访问引用类型（如对象，数组，函数等）的值时，首先从栈中获得该对象的地址指针，然后再从堆内存中取得所需的数据</p> <h4 id="_3、浅拷贝"><a href="#_3、浅拷贝" class="header-anchor">#</a> 3、浅拷贝</h4> <p>前面已经提到，在定义一个对象或数组时，变量存放的往往只是一个地址。当我们使用对象拷贝时，如果属性是对象或数组时，这时候我们传递的也只是一个地址<br>
因此子对象在访问该属性时，会根据地址回溯到父对象指向的堆内存中，即父子对象发生了关联，两者的属性值会指向同一内存空间</p> <h4 id="_4、深拷贝"><a href="#_4、深拷贝" class="header-anchor">#</a> 4、深拷贝</h4> <p>我们不希望父子对象之间产生关联，那么这时候可以用到深拷贝<br>
既然属性值类型是数组和或象时只会传址，那么我们就用递归来解决这个问题，把父对象中所有属于对象的属性类型都遍历赋给子对象即可</p> <h5 id="实现深拷贝"><a href="#实现深拷贝" class="header-anchor">#</a> 实现深拷贝：</h5> <p>JSON.parse() 方法用于将一个 JSON 字符串转换为对象<br>
JSON.stringify() 方法用于将 JavaScript 值（通常为对象或数组）转换为 JSON 字符串
<strong>该方法也是有局限性的：</strong>
会忽略 undefined<br>
会忽略 symbol<br>
不能序列化函数<br>
不能解决循环引用的对象 -&gt; 报错：Converting circular structure to JSON *可以用 lodash 来深拷贝函数</p> <p>ES6：Object.assign(）和展开运算符(...)对于深浅拷贝的结果是一样<br>
如果拷贝的层数超过了一层的话，那么就会进行浅拷贝</p> <h2 id="_21-内存泄漏是什么"><a href="#_21-内存泄漏是什么" class="header-anchor">#</a> 21. 内存泄漏是什么</h2> <p>本质上，内存泄漏可以定义为一个应用，由于某些原因不再需要的内存没有被操作系统或者空闲内存池回收</p> <h4 id="_1、意外的全局变量"><a href="#_1、意外的全局变量" class="header-anchor">#</a> 1、意外的全局变量</h4> <ul><li>在一个函数你忘记用变量声明符(var 或 let)来声明的变量，一个意外的全局变量就被创建了</li></ul> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  str <span class="token operator">=</span> <span class="token string">&quot;str&quot;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>window<span class="token punctuation">.</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><ul><li>在函数中通过 this 赋予变量，在函数中，this 指向 window</li></ul> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>str <span class="token operator">=</span> <span class="token string">&quot;str&quot;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>window<span class="token punctuation">.</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>为了阻止这种错误发生，在你的 Javascript 文件最前面添加'use strict;'
这开启了解析 JavaScript 的阻止意外全局的更严格的模式<br>
如果必须用全局变量来存储很多数据，在处理完之后，确保对其清零或重新赋值</p> <h4 id="_2、定时器-settimeout-setinterval-以及回调函数"><a href="#_2、定时器-settimeout-setinterval-以及回调函数" class="header-anchor">#</a> 2、定时器 setTimeout setInterval 以及回调函数</h4> <p>当不需要 setInterval 或者 setTimeout 时，定时器没有被 clear，定时器的回调函数以及内部依赖的变量都不能被回收，造成内存泄漏<br>
比如：vue 使用了定时器，需要在 beforeDestroy 中做对应销毁处理。js 也是一样的</p> <h4 id="_3、闭包-在全局作用域上保留着闭包局部变量的引用"><a href="#_3、闭包-在全局作用域上保留着闭包局部变量的引用" class="header-anchor">#</a> 3、闭包(在全局作用域上保留着闭包局部变量的引用)</h4> <h4 id="_4、移除存在绑定事件的-dom-元素-ie8-及以下"><a href="#_4、移除存在绑定事件的-dom-元素-ie8-及以下" class="header-anchor">#</a> 4、移除存在绑定事件的 DOM 元素(IE8 及以下)</h4> <h4 id="_5、循环引用"><a href="#_5、循环引用" class="header-anchor">#</a> 5、循环引用</h4> <h2 id="_22-web-安全"><a href="#_22-web-安全" class="header-anchor">#</a> 22. WEB 安全</h2> <h4 id="_1、xss-跨站脚本-cross-site-scripting"><a href="#_1、xss-跨站脚本-cross-site-scripting" class="header-anchor">#</a> 1、XSS：跨站脚本（Cross-site scripting）</h4> <p>利用恶意脚本，攻击者可获取用户的敏感信息如 Cookie 等<br>
根据攻击的来源，XSS 攻击可分为反射型、存储型和 DOM 型三种。</p> <h5 id="_1、反射型"><a href="#_1、反射型" class="header-anchor">#</a> 1、反射型</h5> <p>反射型 XSS 只是简单地把用户输入的数据反射给浏览器。往往需要引诱用户点击一个链接，才能攻击成功</p> <h5 id="_2、存储型"><a href="#_2、存储型" class="header-anchor">#</a> 2、存储型</h5> <p>存储型会把用户输入的数据“存储”在服务器端。比如说评论功能</p> <ul><li>XSS 的防御措施：<br>
1、使用 cookie 的 httpOnly 属性，加上了这个属性的 cookie 字段，js 是无法进行读写的<br>
2、对输入输出进行过滤转义<br>
3、内容安全策略 (CSP) 通过 HTTP Header 中的 Content-Security-Policy 来开启 CSP</li></ul> <h4 id="_2、csrf-跨站请求伪造-cross-site-request-forgery"><a href="#_2、csrf-跨站请求伪造-cross-site-request-forgery" class="header-anchor">#</a> 2、CSRF：跨站请求伪造（Cross-site request forgery）</h4> <p>CSRF 的攻击主要是在用户不知情的情况下，冒充用户偷偷发了请求</p> <ul><li><p>要完成一次 CSRF 攻击，受害者必须依次完成两个步骤：<br>
1、登录受信任网站 A，并在本地生成 Cookie<br>
2、在不登出 A 的情况下，访问危险网站 B。</p></li> <li><p>CSRF 防御措施：<br>
1、检测 http referer 是否是同域名<br>
2、避免登录的 session 长时间存储在客户端中<br>
3、关键请求使用验证码或者 token 机制</p></li></ul> <h2 id="_23-js创建对象的几种方式"><a href="#_23-js创建对象的几种方式" class="header-anchor">#</a> 23. JS创建对象的几种方式</h2> <p><a href="http://cavszhouyou.top/JavaScript%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%B9%8B%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA.html" target="_blank" rel="noopener noreferrer">参考<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a><br>
一共7种，包含工厂模式、构造函数模式、原型模式、组合使用构造函数模式和原型模式、动态原型模式、寄生构造函数模式、稳妥构造函数模式</p> <h3 id="工厂模式"><a href="#工厂模式" class="header-anchor">#</a> 工厂模式</h3> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">createPerson</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">var</span> o <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    o<span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
    o<span class="token punctuation">.</span><span class="token function-variable function">sayName</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token function">alert</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> o<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> person1 <span class="token operator">=</span> <span class="token function">createPerson</span><span class="token punctuation">(</span><span class="token string">&quot;james&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> person2 <span class="token operator">=</span> <span class="token function">createPerson</span><span class="token punctuation">(</span><span class="token string">&quot;kobe&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>优点：解决了创建多个相似对象时，代码的复用问题<br>
缺点：使用工厂模式创建的对象，没有解决对象识别的问题（就是怎样知道一个对象的类型是什么）</p> <h3 id="构造函数模式"><a href="#构造函数模式" class="header-anchor">#</a> 构造函数模式</h3> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">createPerson</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function-variable function">sayName</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token function">alert</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> o<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> person1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">createPerson</span><span class="token punctuation">(</span><span class="token string">&quot;james&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> person2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">createPerson</span><span class="token punctuation">(</span><span class="token string">&quot;kobe&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>优点：解决了工厂模式中对象类型无法识别的问题，并且创建自定义的构造函数意味着将来可以将它的实例标识为一种特定的类型。<br>
缺点：我们知道 ECMAScript 中的函数是对象，在使用构造函数创建对象时，每个方法都会在实例对象中重新创建一遍。拿上面的例子举例，这意味着每创建一个对象，我们就会创建一个 sayName 函数的实例，但它们其实做的都是同样的工作，因此这样便会造成内存的浪费。</p> <h3 id="原型模式"><a href="#原型模式" class="header-anchor">#</a> 原型模式</h3> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">&quot;james&quot;</span><span class="token punctuation">;</span>
<span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">sayName</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token function">alert</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> person1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
person1<span class="token punctuation">.</span><span class="token function">sayName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &quot;james&quot;</span>

<span class="token keyword">var</span> person2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
person2<span class="token punctuation">.</span><span class="token function">sayName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &quot;james&quot;</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person1<span class="token punctuation">.</span>sayName <span class="token operator">===</span> person2<span class="token punctuation">.</span>sayName<span class="token punctuation">)</span> <span class="token comment">// true</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>优点：解决了构造函数模式中多次创建相同函数对象的问题，所有的实例可以共享同一组属性和函数。
缺点：原型模式省略了构造函数模式传递初始化参数的过程，所有的实例在默认情况下都会取得默认的属性值，会在一定程度上造成不方便。</p> <h2 id="_24-作用域链"><a href="#_24-作用域链" class="header-anchor">#</a> 24. 作用域链</h2> <p><a href="http://cavszhouyou.top/JavaScript%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%B9%8B%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE.html" target="_blank" rel="noopener noreferrer">参考<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>定义：当代码在一个环境中执行时，会创建变量对象的一个作用域链。<br>
作用域链的用途是保证对执行环境有权访问的所有变量和函数的有序访问。</p> <h4 id="创建过程"><a href="#创建过程" class="header-anchor">#</a> 创建过程</h4> <ul><li>全局上下文阶段，创建全局对象。</li> <li>将全局对象压入作用域链</li> <li>为全局对象中所有函数创建[[Scope]]属性，并将作用域链保存到该属性。（若无函数则跳过此步骤）</li> <li>每一个函数上下文阶段，复制函数的[[Scope]]属性，创建作用域链</li> <li>创建活动对象，并用 arguments 创建活动对象</li> <li>将活动对象压入当前上下文中的作用域链</li> <li>为活动对象中所有函数创建[[Scope]]属性，并将作用域链保存到该属性。（若无函数则跳过此步骤）</li></ul> <h2 id="_25-js-延迟加载的方式"><a href="#_25-js-延迟加载的方式" class="header-anchor">#</a> 25. JS 延迟加载的方式</h2> <p>JS 延迟加载，也就是等页面加载完成之后再加载JavaScript文件。 JS 延迟加载有助于提高页面加载速度</p> <ul><li>defer 属性</li> <li>async 属性</li> <li>动态创建 DOM 方式</li> <li>使用 setTimeout 延迟方法</li> <li>让 JS 最后加载（对文档的加载事件进行监听，当文档加 载完成后再动态的创建 script 标签来引入 js 脚本）</li></ul> <h2 id="_26-js-模块化方案"><a href="#_26-js-模块化方案" class="header-anchor">#</a> 26. JS 模块化方案</h2> <ul><li>4种方案：CommonJS、AMD、CMD、ES6</li></ul> <h4 id="_26-1、commonjs"><a href="#_26-1、commonjs" class="header-anchor">#</a> 26-1、CommonJS</h4> <p>通过 require 来引入模块，通过 module.exports 定义模块的 输出接口。这种模块加载方案是服务器端的解决方案，它是以同步的方式来引入模块的，因为在 服务端文件都存储在本地磁盘，所以读取非常快，所以以同步的方式加载没有问题。但如果是在 浏览器端，由于模块的加载是使用网络请求，因此使用异步加载的方式更加合适。</p> <h4 id="_26-2、amd"><a href="#_26-2、amd" class="header-anchor">#</a> 26-2、AMD</h4> <p>采用异步加载的方式来加载模块，模块的加载不影响后面语句的 执行，所有依赖这个模块的语句都定义在一个回调函数里，等到加载完成后再执行回调函数。 require.js 实现了 AMD 规范。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// AMD 默认推荐 </span>
<span class="token function">define</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">&quot;./a&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;./b&quot;</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
  <span class="token comment">// 依赖必须一开始就写好</span>
   a<span class="token punctuation">.</span><span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
   <span class="token comment">// 此处略去 100 行 </span>
   b<span class="token punctuation">.</span><span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
   <span class="token comment">// ...</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h4 id="_26-3、cmd"><a href="#_26-3、cmd" class="header-anchor">#</a> 26-3、CMD</h4> <p>这种方案和 AMD 方案都是为了解决异步模块加载的问题，sea.js 实现 了 CMD 规范。它和 require.js 的区别在于模块定义时对依赖的处理不同和对依赖模块的执行 时机的处理不同。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// CMD</span>
<span class="token function">define</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">require<span class="token punctuation">,</span> exports<span class="token punctuation">,</span> module</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
  <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&quot;./a&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
  a<span class="token punctuation">.</span><span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
  <span class="token comment">// 此处略去 100 行 </span>
  <span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&quot;./b&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 依赖可以就近书写 </span>
  b<span class="token punctuation">.</span><span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ...</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h4 id="_26-4、es6"><a href="#_26-4、es6" class="header-anchor">#</a> 26-4、ES6</h4> <p>使用 import 和 export 的形式来导入导出模块。</p> <h2 id="_27-documen-write-和-innerhtml-的区别"><a href="#_27-documen-write-和-innerhtml-的区别" class="header-anchor">#</a> 27. documen.write 和 innerHTML 的区别</h2> <p>document.write 的内容会代替整个文档内容，会重写整个页面。</p> <p>innerHTML 的内容只是替代指定元素的内容，只会重写页面中的部分内容</p> <h2 id="_28-v8下的垃圾回收机制"><a href="#_28-v8下的垃圾回收机制" class="header-anchor">#</a> 28. V8下的垃圾回收机制</h2> <p>V8 实现了准确式 GC，GC 算法采用了分代式垃圾回收机制。因此，V8 将内存（堆）分为<strong>新生代</strong>和<strong>老生代</strong>两部分。</p> <ul><li>新生代空间: 用于存活较短的对象，又分成两个空间: from 空间 与 to 空间</li> <li>Scavenge GC算法: 当 from 空间被占满时，启动 GC 算法<br>
1、存活的对象从 from space 转移到 to space<br>
2、清空 from space<br>
3、from space 与 to space 互换<br>
4、完成一次新生代GC</li></ul> <p>在新生代空间中，内存空间分为两部分，分别为 From 空间和 To 空间。在这两个空间中，必定有一个空间是使用的，另一个空间是空闲的。<br>
新分配的对象会被放入 From 空间中，当 From 空间被占满时，新生代 GC 就会启动了。算法会检查 From 空间中存活的对象并复制到 To 空间中，如果有失活的对象就会销毁。<br>
当复制完成后将 From 空间和 To 空间互换，这样 GC 就结束了。</p> <ul><li><p>老生代空间: 用于存活时间较长的对象</p></li> <li><p>从 新生代空间 转移到 老生代空间 的条件，满足其一即可<br>
1、经历过一次以上 Scavenge GC 的对象<br>
2、当 to space 体积超过25%</p></li> <li><p>标记清除算法： 标记存活的对象，未被标记的则被释放<br>
增量标记: 小模块标记，在代码执行间隙，GC 会影响性能<br>
并发标记(最新技术): 不阻塞 js 执行</p></li> <li><p>标记压缩算法：: 将内存中清除后导致的碎片化对象往内存堆的一端移动，解决 内存的碎片化</p></li></ul> <h2 id="_29-0-1-0-2-0-3"><a href="#_29-0-1-0-2-0-3" class="header-anchor">#</a> 29. 0.1 + 0.2 != 0.3</h2> <div class="language-js line-numbers-mode"><pre class="language-js"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">0.1</span> <span class="token operator">+</span> <span class="token number">0.2</span> <span class="token operator">===</span> <span class="token number">0.3</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">0.1</span> <span class="token operator">+</span> <span class="token number">0.2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 0.30000000000000004</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>JS数字采用IEEE 754 双精度 64 位浮点数来存储,在js中数字只能保存小数点后52位，第53位为0省略，</p> <ul><li>原生办法解决：</li></ul> <div class="language-js line-numbers-mode"><pre class="language-js"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">parseFloat</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">0.1</span> <span class="token operator">+</span> <span class="token number">0.2</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toFixed</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token number">0.3</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">parseFloat</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">0.1</span> <span class="token operator">+</span> <span class="token number">0.2</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toFixed</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 0.3</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h2 id="_30-性能定义和性能优化"><a href="#_30-性能定义和性能优化" class="header-anchor">#</a> 30. 性能定义和性能优化</h2> <p><a href="https://mp.weixin.qq.com/s/Ah3L4VKh_RWY1_-AnrVbyQ" target="_blank" rel="noopener noreferrer">参考<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <ul><li>性能优化分为两个大的分类
1、加载时优化<br>
2、运行时优化</li></ul> <h3 id="_30-1、加载时性能"><a href="#_30-1、加载时性能" class="header-anchor">#</a> 30-1、加载时性能</h3> <p>顾名思义加载时优化 主要解决的就是让一个网站加载过程更快，比如压缩文件大小、使用CDN加速等方式可以优化加载性能。</p> <p><strong>检查加载性能的指标一般看：白屏时间和首屏时间</strong></p> <p>白屏时间：指的是从输入网址， 到页面开始显示内容的时间。<br>
首屏时间：指从输入网址， 到首屏页面内容渲染完毕的时间。</p> <ul><li>白屏时间计算</li></ul> <p>将代码脚本放在<code>head</code>标签前面就能获取白屏时间</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token operator">&lt;</span>script<span class="token operator">&gt;</span>
    <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> performance<span class="token punctuation">.</span>timing<span class="token punctuation">.</span>navigationStart
<span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><ul><li>首屏时间计算</li></ul> <p>在window.onload事件中执行以下代码，可以获取首屏时间</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> performance<span class="token punctuation">.</span>timing<span class="token punctuation">.</span>navigationStart
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h4 id="加载时性能优化"><a href="#加载时性能优化" class="header-anchor">#</a> 加载时性能优化</h4> <p>浏览器如果输入的是一个网址，首先要交给DNS域名解析 -&gt; 找到对应的IP地址 -&gt; 然后进行TCP连接 -&gt; 浏览器发送HTTP请求 -&gt; 服务器接收请求 -&gt; 服务器处理请求并返回HTTP报文 -&gt; 以及浏览器接收并解析渲染页面。<br>
从这一过程中，其实就可以挖出优化点，缩短请求的时间，从而去加快网站的访问速度，提升性能。</p> <p><strong>这个过程中可以提升性能的优化的点：</strong></p> <p>1、DNS解析优化，浏览器访问DNS的时间就可以缩短<br>
2、使用HTTP2<br>
3、减少HTTP请求数量<br>
4、减少http请求大小<br>
5、服务器端渲染<br>
6、静态资源使用CDN<br>
7、资源缓存，不重复加载相同的资源</p> <ul><li>1、DNS 预解析</li></ul> <p>用meta信息来告知浏览器, 当前页面要做DNS预解析</p> <div class="language-html line-numbers-mode"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>x-dns-prefetch-control<span class="token punctuation">&quot;</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>on<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>在页面header中使用link标签来强制对DNS预解析</p> <div class="language-html line-numbers-mode"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>dns-prefetch<span class="token punctuation">&quot;</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>http://bdimg.share.baidu.com<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><strong>注意：dns-prefetch需慎用，多页面重复DNS预解析会增加重复DNS查询次数。</strong></p> <ul><li>2、使用HTTP2</li></ul> <p>HTTP2带来了非常大的加载优化，所以在做优化上首先就想到了用HTTP2代替HTTP1。</p> <p>HTTP2相对于HTTP1有这些优点：<strong>解析速度快、多路复用、首部压缩、服务器推送</strong></p> <ul><li>3、减少HTTP请求数量</li></ul> <p>HTTP请求建立和释放需要时间。</p> <p>HTTP请求从建立到关闭一共经过以下步骤：</p> <p>1、客户端连接到Web服务器<br>
2、发送HTTP请求<br>
3、服务器接受请求并返回HTTP响应<br>
4、释放连接TCP链接</p> <ul><li>4、压缩、合并文件</li></ul> <p>压缩文件 -&gt; 减少HTTP请求大小,可以减少请求时间<br>
文件合并 -&gt; 减少HTTP请求数量。</p> <p>我们可以对html、css、js以及图片资源进行压缩处理，现在可以很方便的使用 webpack 实现文件的压缩</p> <p>JS压缩：UglifyPlugin<br>
CSS压缩：MiniCssExtractPlugin<br>
HTML压缩：HtmlWebpackPlugin<br>
图片压缩：image-webpack-loader</p> <ul><li>5、服务端启用gzip，减少传输文件的体积</li></ul> <h3 id="_30-2、运行时性能"><a href="#_30-2、运行时性能" class="header-anchor">#</a> 30-2、运行时性能</h3> <p>运行时性能是指页面运行时的性能表现，而不是页面加载时的性能。<br>
可以通过chrome开发者工具中的 Performance 面板来分析页面的运行时性能。</p> <h2 id="_31-尾调用及其好处"><a href="#_31-尾调用及其好处" class="header-anchor">#</a> 31. 尾调用及其好处</h2> <p>尾调用指的是函数的最后一步调用另一个函数。我们代码执行是基于执行栈的， 所以当我们在一个函数里调用另一个函数时，我们会保留当前的执行上下文，然 后再新建另外一个执行上下文加入栈中。<br>
使用尾调用的话，因为已经是函数的最 后一步，所以这个时候我们可以不必再保留当前的执行上下文，从而节省了内存， 这就是尾调用优化。<br>
ES6 的尾调用优化只在严格模式下开启，正常模式是无效的。</p> <h2 id="_32-cookies-sessionstorage-和-localstorage-的区别"><a href="#_32-cookies-sessionstorage-和-localstorage-的区别" class="header-anchor">#</a> 32.cookies，sessionStorage 和 localStorage 的区别</h2> <p><strong>共同点：都是保存在浏览器端，且同源的</strong></p> <table><thead><tr><th style="text-align:center;">特性​</th> <th style="text-align:center;">​​Cookies​</th> <th style="text-align:center;">​​sessionStorage​</th> <th style="text-align:center;">​​localStorage​</th></tr></thead> <tbody><tr><td style="text-align:center;">​​存储容量​</td> <td style="text-align:center;">4KB 左右（每个域名）</td> <td style="text-align:center;">5-10MB（不同浏览器不同）</td> <td style="text-align:center;">5-10MB（甚至更大）</td></tr> <tr><td style="text-align:center;">生命周期​</td> <td style="text-align:center;">可设置过期时间（默认会话级，关闭浏览器后清除）<br> 通过 expires 或 max-age 设置过期时间</td> <td style="text-align:center;">​​会话级​​（关闭标签页清除）</td> <td style="text-align:center;">​永久存储​​（需手动清除）</td></tr> <tr><td style="text-align:center;">作用域​</td> <td style="text-align:center;">同域名下所有标签页共享</td> <td style="text-align:center;">​仅当前标签页​</td> <td style="text-align:center;">同域名下所有标签页共享</td></tr> <tr><td style="text-align:center;">同步行为</td> <td style="text-align:center;">修改后立即同步</td> <td style="text-align:center;">完全不共享</td> <td style="text-align:center;">需通过 storage 事件监听同步</td></tr> <tr><td style="text-align:center;">​​是否随请求发送​</td> <td style="text-align:center;">是（自动附加到 HTTP 请求头）</td> <td style="text-align:center;">否</td> <td style="text-align:center;">否</td></tr> <tr><td style="text-align:center;">​典型用途</td> <td style="text-align:center;">用户认证、会话跟踪</td> <td style="text-align:center;">临时表单数据、页面间传参</td> <td style="text-align:center;">长期存储（如用户偏好设置）</td></tr> <tr><td style="text-align:center;">安全注意事项</td> <td style="text-align:center;">敏感数据应标记 HttpOnly 和 Secure（防止 XSS 和嗅探）</td> <td style="text-align:center;">不要存储敏感信息（如密码），易受 XSS 攻击</td> <td style="text-align:center;">不要存储敏感信息（如密码），易受 XSS 攻击</td></tr></tbody></table> <h4 id="cookies​​"><a href="#cookies​​" class="header-anchor">#</a> Cookies​​：</h4> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// 设置 Cookie（需手动处理字符串） </span>
<span class="token comment">// Cookies​还有路径（path）的概念，可以限制 cookie 只属于某个路径下</span>
document<span class="token punctuation">.</span>cookie <span class="token operator">=</span> <span class="token string">&quot;username=John; expires=Thu, 18 Dec 2025 12:00:00 UTC; path=/&quot;</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h4 id="sessionstorage-localstorage​​"><a href="#sessionstorage-localstorage​​" class="header-anchor">#</a> sessionStorage/localStorage​​：</h4> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// 使用 Web Storage API（简单易用）</span>
localStorage<span class="token punctuation">.</span><span class="token function">setItem</span><span class="token punctuation">(</span><span class="token string">'theme'</span><span class="token punctuation">,</span> <span class="token string">'dark'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
sessionStorage<span class="token punctuation">.</span><span class="token function">setItem</span><span class="token punctuation">(</span><span class="token string">'tempData'</span><span class="token punctuation">,</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h2 id="_33-​​indexeddb​​-以及-service-worker-cache-api​"><a href="#_33-​​indexeddb​​-以及-service-worker-cache-api​" class="header-anchor">#</a> 33.​​IndexedDB​​ 以及 Service Worker + Cache API​</h2> <table><thead><tr><th style="text-align:center;">​​维度​</th> <th style="text-align:center;">​IndexedDB​</th> <th style="text-align:center;">Service Worker + Cache API​</th></tr></thead> <tbody><tr><td style="text-align:center;">​​数据用途​</td> <td style="text-align:center;">动态结构化数据（如用户数据、日志）</td> <td style="text-align:center;">静态资源或网络请求响应（如 HTML、API）</td></tr> <tr><td style="text-align:center;">​​离线支持​</td> <td style="text-align:center;">需配合 Service Worker 实现完整离线功能</td> <td style="text-align:center;">直接支持离线资源加载</td></tr> <tr><td style="text-align:center;">查询能力​</td> <td style="text-align:center;">支持复杂查询（索引、游标）</td> <td style="text-align:center;">仅能通过 URL 匹配缓存</td></tr> <tr><td style="text-align:center;">​​适用场景​</td> <td style="text-align:center;">数据库类应用（如本地笔记、编辑器）</td> <td style="text-align:center;">离线优先的 Web 应用（如新闻、文档阅读）</td></tr></tbody></table> <h4 id="indexeddb-客户端大规模结构化数据存储​"><a href="#indexeddb-客户端大规模结构化数据存储​" class="header-anchor">#</a> IndexedDB：客户端大规模结构化数据存储​</h4> <ul><li>核心特性​​
<ul><li>​类型​​：基于 JavaScript 的 NoSQL 数据库，支持索引、事务和异步操作。</li> <li>​容量​​：浏览器通常允许存储数百 MB 甚至 GB 级数据（取决于用户设备）。</li> <li>数据结构​​：存储键值对（值可以是复杂对象、文件二进制数据等）。</li> <li>异步 API​​：所有操作非阻塞，通过事件或 Promise 返回结果。
​​</li></ul></li> <li>适用场景​​
<ul><li>需要存储大量结构化数据（如用户生成的文档、离线应用数据）。</li> <li>需要高性能查询（通过索引快速检索）。</li> <li>需要事务支持（保证数据一致性，如金融类应用）。</li></ul></li></ul> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// 打开或创建数据库</span>
<span class="token keyword">const</span> request <span class="token operator">=</span> indexedDB<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">'MyDatabase'</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

request<span class="token punctuation">.</span><span class="token function-variable function">onupgradeneeded</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">event</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> db <span class="token operator">=</span> event<span class="token punctuation">.</span>target<span class="token punctuation">.</span>result<span class="token punctuation">;</span>
  <span class="token comment">// 创建对象存储空间（类似表）</span>
  <span class="token keyword">const</span> store <span class="token operator">=</span> db<span class="token punctuation">.</span><span class="token function">createObjectStore</span><span class="token punctuation">(</span><span class="token string">'users'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token literal-property property">keyPath</span><span class="token operator">:</span> <span class="token string">'id'</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 创建索引</span>
  store<span class="token punctuation">.</span><span class="token function">createIndex</span><span class="token punctuation">(</span><span class="token string">'nameIndex'</span><span class="token punctuation">,</span> <span class="token string">'name'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token literal-property property">unique</span><span class="token operator">:</span> <span class="token boolean">false</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

request<span class="token punctuation">.</span><span class="token function-variable function">onsuccess</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">event</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> db <span class="token operator">=</span> event<span class="token punctuation">.</span>target<span class="token punctuation">.</span>result<span class="token punctuation">;</span>
  <span class="token comment">// 插入数据</span>
  <span class="token keyword">const</span> transaction <span class="token operator">=</span> db<span class="token punctuation">.</span><span class="token function">transaction</span><span class="token punctuation">(</span><span class="token string">'users'</span><span class="token punctuation">,</span> <span class="token string">'readwrite'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> store <span class="token operator">=</span> transaction<span class="token punctuation">.</span><span class="token function">objectStore</span><span class="token punctuation">(</span><span class="token string">'users'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  store<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'Alice'</span><span class="token punctuation">,</span> <span class="token literal-property property">age</span><span class="token operator">:</span> <span class="token number">30</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// 查询数据</span>
  <span class="token keyword">const</span> getRequest <span class="token operator">=</span> store<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  getRequest<span class="token punctuation">.</span><span class="token function-variable function">onsuccess</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>getRequest<span class="token punctuation">.</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// { id: 1, name: 'Alice', age: 30 }</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br></div></div><h4 id="service-worker-cache-api-离线应用缓存​"><a href="#service-worker-cache-api-离线应用缓存​" class="header-anchor">#</a> Service Worker + Cache API：离线应用缓存​</h4> <ul><li><p>​Service Worker​​：</p> <ul><li>独立于主线程的脚本，可拦截网络请求、管理缓存。</li> <li>支持离线运行和后台同步。</li></ul></li> <li><p>​Cache API​​：</p> <ul><li>提供缓存存储机制（键值对，键为请求对象，值为响应对象）。</li> <li>可缓存 HTML、CSS、JS、图片等静态资源或 API 响应</li></ul></li> <li><p>适用场景​​</p> <ul><li>构建离线可用的 PWA（渐进式 Web 应用）。</li> <li>加速重复访问的静态资源加载。</li> <li>实现自定义缓存策略（如“网络优先，失败后回退缓存”）。</li></ul></li></ul></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">lastUpdate:</span> <span class="time">5/5/2025, 8:38:10 AM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/Front-end-go-on/pages/frontend/base/Css.html" class="prev">
        CSS基础
      </a></span> <span class="next"><a href="/Front-end-go-on/pages/frontend/base/ES6.html">
        ES6基础
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/Front-end-go-on/assets/js/app.516772f1.js" defer></script><script src="/Front-end-go-on/assets/js/2.0a3bc84c.js" defer></script><script src="/Front-end-go-on/assets/js/20.a1860b1a.js" defer></script>
  </body>
</html>
