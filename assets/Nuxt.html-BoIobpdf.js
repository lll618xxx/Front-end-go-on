import{_ as e,c as a,a as n,o as s}from"./app-ZekJYtLD.js";const l={};function i(d,t){return s(),a("div",null,[...t[0]||(t[0]=[n(`<h2 id="_1、nuxt-js-概念" tabindex="-1"><a class="header-anchor" href="#_1、nuxt-js-概念"><span>1、Nuxt.js 概念</span></a></h2><h3 id="_1-1、nuxt-js-是什么" tabindex="-1"><a class="header-anchor" href="#_1-1、nuxt-js-是什么"><span>1-1、Nuxt.js 是什么？</span></a></h3><p>基于 Vue.js 的全栈框架，提供开箱即用的服务端渲染（SSR）、静态站点生成（SSG）、API 路由等功能。</p><p>核心目标：简化 Vue 应用的开发流程，提升 SEO 和首屏加载性能。</p><h3 id="_1-2、核心特性" tabindex="-1"><a class="header-anchor" href="#_1-2、核心特性"><span>1-2、核心特性</span></a></h3><ul><li>服务端渲染（SSR）：服务器生成 HTML 发送到客户端。</li><li>静态站点生成（SSG）：预渲染页面为静态 HTML。</li><li>自动路由：基于 pages/ 目录结构生成路由。</li><li>模块化：通过模块扩展功能（如 Axios、Auth、Tailwind 等）。</li><li>开发友好：热更新、TypeScript 支持、Vite 集成（Nuxt 3+）。</li></ul><h3 id="_1-3、核心原理-同构渲染" tabindex="-1"><a class="header-anchor" href="#_1-3、核心原理-同构渲染"><span>1-3、核心原理（同构渲染）</span></a></h3><ul><li>编译阶段：将 Vue 组件编译为可在 Node.js 运行的服务端 bundle</li><li>服务端渲染：在 Node.js 中创建 Vue 实例，执行 asyncData 获取数据，渲染为 HTML</li><li>客户端激活：浏览器下载 HTML 和 JS 后，Vue 会接管静态 HTML 使其可交互</li><li>状态同步：通过 window.__NUXT__将服务端状态传递到客户端</li></ul><h3 id="_1-4、ssr和ssg对比" tabindex="-1"><a class="header-anchor" href="#_1-4、ssr和ssg对比"><span>1-4、SSR和SSG对比</span></a></h3><ul><li>服务端渲染（SSR）：服务器生成 HTML 发送到客户端。</li></ul><div class="hint-container tip"><p class="hint-container-title">提示</p><p>// SSR - 请求时渲染<br> 用户请求 → 服务器 → Nuxt应用 → 执行asyncData → 渲染HTML → 返回给用户<br> ↓<br> 每个请求都重新执行</p></div><ul><li>静态站点生成（SSG）：预渲染页面为静态 HTML。</li></ul><div class="hint-container tip"><p class="hint-container-title">提示</p><p>// SSG - 构建时预渲染<br> npm run generate → 爬取路由 → 执行asyncData → 生成HTML文件 → 部署到CDN<br> ↓<br> 用户请求 → CDN直接返回预生成的HTML</p></div><table><thead><tr><th style="text-align:center;">特性维度</th><th style="text-align:center;">SSR (服务端渲染)</th><th style="text-align:center;">SSG (静态站点生成)</th></tr></thead><tbody><tr><td style="text-align:center;">渲染时机</td><td style="text-align:center;">每次请求时实时渲染</td><td style="text-align:center;">构建时预渲染</td></tr><tr><td style="text-align:center;">部署位置</td><td style="text-align:center;">Node.js 服务器</td><td style="text-align:center;">CDN/静态服务器</td></tr><tr><td style="text-align:center;">数据更新</td><td style="text-align:center;">实时更新</td><td style="text-align:center;">重新构建后更新</td></tr><tr><td style="text-align:center;">首屏性能</td><td style="text-align:center;">快 (服务端生成HTML)</td><td style="text-align:center;">极快 (CDN缓存)</td></tr><tr><td style="text-align:center;">适合场景</td><td style="text-align:center;">​动态内容、用户交互</td><td style="text-align:center;">内容稳定、访问量大</td></tr></tbody></table><h2 id="_2、asyncdata-和-fetch-的区别" tabindex="-1"><a class="header-anchor" href="#_2、asyncdata-和-fetch-的区别"><span>2、asyncData 和 fetch 的区别</span></a></h2><table><thead><tr><th style="text-align:center;">特性</th><th style="text-align:center;">asyncData</th><th style="text-align:center;">fetch (Nuxt 2.12+)</th></tr></thead><tbody><tr><td style="text-align:center;">​​this 访问​</td><td style="text-align:center;">不可用</td><td style="text-align:center;">可用</td></tr><tr><td style="text-align:center;">​​​​返回值​​</td><td style="text-align:center;">合并到组件 data</td><td style="text-align:center;">无返回值</td></tr><tr><td style="text-align:center;">​​使用位置​</td><td style="text-align:center;">仅页面组件</td><td style="text-align:center;">所有组件</td></tr><tr><td style="text-align:center;">​​存储位置​</td><td style="text-align:center;">组件 data</td><td style="text-align:center;">Vuex store</td></tr><tr><td style="text-align:center;">执行时机​</td><td style="text-align:center;">组件创建前</td><td style="text-align:center;">组件创建后</td></tr></tbody></table><h2 id="_3、在-nuxt-中实现全局状态管理" tabindex="-1"><a class="header-anchor" href="#_3、在-nuxt-中实现全局状态管理"><span>3、在 Nuxt 中实现全局状态管理</span></a></h2><p>Nuxt 2：默认集成 Vuex，通过 store/ 目录自动注册模块。</p><p>Nuxt 3：推荐使用 Pinia（需手动安装），或轻量级方案 useState（基于 Composition API）。</p><h2 id="_4、如何优化-nuxt-应用的-seo" tabindex="-1"><a class="header-anchor" href="#_4、如何优化-nuxt-应用的-seo"><span>4、如何优化 Nuxt 应用的 SEO？</span></a></h2><p>使用 useHead（Nuxt 3）或 head() 方法配置页面标题、描述、结构化数据。</p><p>服务端渲染（SSR）或静态生成（SSG）确保爬虫可抓取完整内容。</p><p>合理使用 meta 标签和 Open Graph 协议。</p><h2 id="_5、nuxt-模块的作用是什么" tabindex="-1"><a class="header-anchor" href="#_5、nuxt-模块的作用是什么"><span>5、Nuxt 模块的作用是什么</span></a></h2><p>Nuxt 模块用于扩展框架功能，例如：</p><ul><li><p>@nuxtjs/axios：封装 HTTP 请求，支持服务端和客户端调用。</p></li><li><p>@nuxt/image：自动优化图片（压缩、懒加载、适配多分辨率）。</p></li><li><p>配置方式：在 nuxt.config.js 的 modules 数组中引入。</p></li></ul><h2 id="_6、如何实现-nuxt-应用的性能优化" tabindex="-1"><a class="header-anchor" href="#_6、如何实现-nuxt-应用的性能优化"><span>6、如何实现 Nuxt 应用的性能优化</span></a></h2><ul><li><p>代码拆分：利用 Nuxt 自动按页面拆分代码的特性。</p></li><li><p>静态缓存：对不常变动的页面使用 nuxt generate 生成静态 HTML。</p></li><li><p>图片优化：通过 @nuxt/image 实现懒加载和格式转换。</p></li><li><p>CDN 加速：配置 publicPath 指向 CDN 地址。</p></li></ul><h2 id="_7、如何在-nuxt-中处理服务端和客户端环境差异" tabindex="-1"><a class="header-anchor" href="#_7、如何在-nuxt-中处理服务端和客户端环境差异"><span>7、如何在 Nuxt 中处理服务端和客户端环境差异</span></a></h2><ul><li>使用 process.client 或 process.server 判断当前环境。</li></ul><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code class="language-javascript"><span class="line"><span class="token keyword">if</span> <span class="token punctuation">(</span>process<span class="token punctuation">.</span>client<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>window<span class="token punctuation">.</span>innerWidth<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>避免在 asyncData 中使用浏览器 API（如 window），可在 mounted 生命周期或客户端钩子中调用。</li></ul><h2 id="_8、在-nuxt-ssr-中​​不会执行​​的-vue-生命周期钩子" tabindex="-1"><a class="header-anchor" href="#_8、在-nuxt-ssr-中​​不会执行​​的-vue-生命周期钩子"><span>8、在 Nuxt SSR 中​​不会执行​​的 Vue 生命周期钩子</span></a></h2><ul><li><ol><li>与 DOM 相关的钩子​​：</li></ol><ul><li><code>beforeMount</code>/<code>mounted</code>：涉及 DOM 挂载</li><li><code>beforeUpdate</code>/<code>updated</code>：涉及 DOM 更新</li><li>SSR 环境下没有真实的 DOM 操作</li></ul></li><li><ol start="2"><li>​​组件激活/卸载相关钩子​​：</li></ol><ul><li><code>activated</code>/<code>deactivated</code>：与 keep-alive 组件相关</li><li><code>beforeDestroy</code>/<code>destroyed</code>：组件卸载行为</li><li>这些都属于客户端特有的行为</li></ul></li></ul>`,34)])])}const c=e(l,[["render",i]]),p=JSON.parse('{"path":"/pages/frontend/frame/base/Nuxt.html","title":"","lang":"zh-CN","frontmatter":{},"git":{"updatedTime":1767877094000,"contributors":[{"name":"lixx","username":"","email":"837435186@qq.com","commits":2},{"name":"nxiang","username":"","email":"837435186@qq.com","commits":1}],"changelog":[{"hash":"fdd1e2123693f2a5441d27b9c8a266a539a0931b","time":1767877094000,"email":"837435186@qq.com","author":"nxiang","message":"update"},{"hash":"278626f19585fd184b1ee11e826f4fcee047127a","time":1747648806000,"email":"837435186@qq.com","author":"lixx","message":"update"},{"hash":"d3797e73a8ff3f9ab82bab4b443dfc1b582179f3","time":1741335988000,"email":"837435186@qq.com","author":"lixx","message":"111"}]},"filePathRelative":"pages/frontend/frame/base/Nuxt.md"}');export{c as comp,p as data};
