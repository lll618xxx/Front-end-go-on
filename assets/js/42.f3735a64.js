(window.webpackJsonp=window.webpackJsonp||[]).push([[42],{361:function(t,e,a){"use strict";a.r(e);var v=a(13),r=Object(v.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h2",{attrs:{id:"_1-vue和react的区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-vue和react的区别"}},[t._v("#")]),t._v(" 1. Vue和React的区别：")]),t._v(" "),e("h4",{attrs:{id:"相同点-使用-virtual-dom"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#相同点-使用-virtual-dom"}},[t._v("#")]),t._v(" 相同点：使用 Virtual DOM")]),t._v(" "),e("p",[t._v("都能使用服务端渲染 React(Next.js)、 Vue(Nuxt.js)")]),t._v(" "),e("p",[t._v("中心思想相同：一切都是组件，组件实例之间可以嵌套；都提供合理的钩子函数")]),t._v(" "),e("h4",{attrs:{id:"不同点-在-react-应用中-当某个组件的状态发生变化时-它会以该组件为根-重新渲染整个组件子树。"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#不同点-在-react-应用中-当某个组件的状态发生变化时-它会以该组件为根-重新渲染整个组件子树。"}},[t._v("#")]),t._v(" 不同点：在 React 应用中，当某个组件的状态发生变化时，它会以该组件为根，重新渲染整个组件子树。")]),t._v(" "),e("p",[t._v("在 Vue 应用中，组件的依赖是在渲染过程中自动追踪的，所以系统能精确知晓哪个组件确实需要被重渲染。")]),t._v(" "),e("p",[t._v("React采用特殊的JSX语法，Vue.js在组件开发中推崇编写.vue特殊文件格式")]),t._v(" "),e("h2",{attrs:{id:"_2、vue和react分别在哪个生命周期发起ajax请求"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2、vue和react分别在哪个生命周期发起ajax请求"}},[t._v("#")]),t._v(" 2、Vue和React分别在哪个生命周期发起Ajax请求")]),t._v(" "),e("h4",{attrs:{id:"vue"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vue"}},[t._v("#")]),t._v(" vue：")]),t._v(" "),e("p",[t._v("在获取数据后，对数据的处理如果不涉及DOM，可在 created 阶段获取，毕竟速度更快一些")]),t._v(" "),e("p",[t._v("如果数据涉及到DOM的处理，则要在mounted阶段获取数据")]),t._v(" "),e("h4",{attrs:{id:"react"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#react"}},[t._v("#")]),t._v(" react：")]),t._v(" "),e("p",[t._v("放在"),e("code",[t._v("componentDidMount")]),t._v("阶段获取")]),t._v(" "),e("p",[t._v("该生命周期在组件已经完全挂载到网页上才会调用被执行，所以可以保证数据的加载")]),t._v(" "),e("h2",{attrs:{id:"_3、vue-和-react-shouldcomponentupdate-性能异同"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3、vue-和-react-shouldcomponentupdate-性能异同"}},[t._v("#")]),t._v(" 3、Vue 和 React（shouldComponentUpdate ）性能异同")]),t._v(" "),e("ul",[e("li",[t._v("在 React 应用中，当某个组件的状态发生变化时，它会以该组件为根，重新渲染整个组件子树")])]),t._v(" "),e("p",[t._v("如要避免不必要的子组件的重渲染，你需要在所有可能的地方使用 PureComponent，或是手动实现 shouldComponentUpdate 方法。")]),t._v(" "),e("ul",[e("li",[t._v("在 Vue 应用中，组件的依赖是在渲染过程中自动追踪的")])]),t._v(" "),e("h2",{attrs:{id:"_4、vuex、redux、mobx的区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4、vuex、redux、mobx的区别"}},[t._v("#")]),t._v(" 4、vuex、redux、mobx的区别")]),t._v(" "),e("p",[t._v("Redux 和 Vuex 是基于 Flux 的")]),t._v(" "),e("p",[t._v("Flux 、Redux 、Vuex 均为单向数据流。")]),t._v(" "),e("p",[t._v("Flux 与 MobX 可以有多个 Store ，Redux 、Vuex 全局仅有一个 Store（单状态树）。\n        \n#### redux和mobx的相同点：")]),t._v(" "),e("ul",[e("li",[t._v("1、统一维护管理应用状态")]),t._v(" "),e("li",[t._v("2、某一状态只有一个可信数据来源-store 状态容器")]),t._v(" "),e("li",[t._v("3、操作更新状态方式统一，并且可控(通常以action方式提供更新状态的途径)")]),t._v(" "),e("li",[t._v("4、将react组件从业务上分为容器组件和展示型组件(视图)")])]),t._v(" "),e("h4",{attrs:{id:"redux和mobx的不同点"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#redux和mobx的不同点"}},[t._v("#")]),t._v(" redux和mobx的不同点：")]),t._v(" "),e("ul",[e("li",[t._v("1、在Redux中，我们总是将所有共享的数据集中在一个大的store中，而Mobx则通常按模块将应用状态划分，在多个独立的store中管理")]),t._v(" "),e("li",[t._v("2、Redux 更多的是遵循函数式编程思想，而Mobx更多的是从面向对象角度考虑问题")]),t._v(" "),e("li",[t._v("3、Redux状态通常是不可变的，不能直接操作状态对象，而是在原来状态基础上返回一个新的状态对象，而Mobx中直接使用新值更新状态对象")]),t._v(" "),e("li",[t._v("4、Redux以javascript原生对象形式存储数据，而Mobx使用可观察对象")])])])}),[],!1,null,null,null);e.default=r.exports}}]);