(window.webpackJsonp=window.webpackJsonp||[]).push([[22],{277:function(t,a,e){"use strict";e.r(a);var r=e(28),s=Object(r.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h2",{attrs:{id:"_1、vue-和-react-分别在哪个生命周期发起ajax请求"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1、vue-和-react-分别在哪个生命周期发起ajax请求"}},[t._v("#")]),t._v(" 1、Vue 和 React 分别在哪个生命周期发起Ajax请求")]),t._v(" "),e("h4",{attrs:{id:"vue："}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vue："}},[t._v("#")]),t._v(" vue：")]),t._v(" "),e("p",[t._v("  在获取数据后，对数据的处理如果不涉及DOM，可在 created 阶段获取，毕竟速度更快一些"),e("br"),t._v("\n  如果数据涉及到DOM的处理，则要在 mounted 阶段获取数据")]),t._v(" "),e("h4",{attrs:{id:"react："}},[e("a",{staticClass:"header-anchor",attrs:{href:"#react："}},[t._v("#")]),t._v(" react：")]),t._v(" "),e("p",[t._v("  放在 componentDidMount 阶段获取"),e("br"),t._v("\n  该生命周期在组件已经完全挂载到网页上才会调用被执行，所以可以保证数据的加载")]),t._v(" "),e("h2",{attrs:{id:"_2、vue-和-react（shouldcomponentupdate-）性能异同"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2、vue-和-react（shouldcomponentupdate-）性能异同"}},[t._v("#")]),t._v(" 2、Vue 和 React（shouldComponentUpdate ）性能异同")]),t._v(" "),e("h4",{attrs:{id:"vue：-2"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vue：-2"}},[t._v("#")]),t._v(" vue：")]),t._v(" "),e("p",[t._v("  在 Vue 应用中，组件的依赖是在渲染过程中自动追踪的")]),t._v(" "),e("h4",{attrs:{id:"react：-2"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#react：-2"}},[t._v("#")]),t._v(" react：")]),t._v(" "),e("p",[t._v("  在 React 应用中，当某个组件的状态发生变化时，它会以该组件为根，重新渲染整个组件子树"),e("br"),t._v("\n  如要避免不必要的子组件的重渲染，你需要在所有可能的地方使用 PureComponent，或是手动实现 shouldComponentUpdate 方法。")])])}),[],!1,null,null,null);a.default=s.exports}}]);